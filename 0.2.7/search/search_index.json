{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"AfterEffects Addon","text":"<p>Integration with Adobe AfterEffects.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_aftereffects<ul> <li>addon</li> <li>api<ul> <li>extension<ul> <li>CSXS</li> <li>css</li> <li>icons</li> <li>js<ul> <li>libs</li> </ul> </li> <li>jsx</li> </ul> </li> <li>launch_logic</li> <li>launch_script</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>webserver</li> <li>workfile_template_builder</li> <li>ws_stub</li> </ul> </li> <li>hooks<ul> <li>pre_launch_args</li> <li>pre_launch_install_ayon_extension</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_render</li> <li>workfile_creator</li> </ul> </li> <li>load<ul> <li>load_background</li> <li>load_file</li> </ul> </li> <li>publish<ul> <li>add_publish_highlight</li> <li>closeAE</li> <li>collect_audio</li> <li>collect_current_file</li> <li>collect_extension_version</li> <li>collect_render</li> <li>collect_rendered_files</li> <li>collect_review</li> <li>collect_workfile</li> <li>extract_compositions</li> <li>extract_local_render</li> <li>extract_save_scene</li> <li>help</li> <li>increment_workfile</li> <li>remove_publish_highlight</li> <li>validate_footage_items</li> <li>validate_instance_folder</li> <li>validate_rendered_files</li> <li>validate_scene_settings</li> </ul> </li> <li>workfile_build<ul> <li>create_placeholder</li> <li>load_placeholder</li> </ul> </li> </ul> </li> <li>resources</li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>creator_plugins</li> <li>imageio</li> <li>main</li> <li>publish_plugins</li> <li>templated_workfile_build</li> <li>workfile_builder</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/index.html","title":"client","text":""},{"location":"autoapi/client/ayon_aftereffects/index.html","title":"ayon_aftereffects","text":""},{"location":"autoapi/client/ayon_aftereffects/index.html#client.ayon_aftereffects.AfterEffectsAddon","title":"<code>AfterEffectsAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_aftereffects/addon.py</code> <pre><code>class AfterEffectsAddon(AYONAddon, IHostAddon):\n    name = \"aftereffects\"\n    version = __version__\n    host_name = \"aftereffects\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"WEBSOCKET_URL\": \"ws://localhost:8097/ws/\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_workfile_extensions(self):\n        return [\".aep\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(AFTEREFFECTS_ADDON_ROOT, \"hooks\")\n        ]\n\n    def publish_in_test(self, log, close_plugin_name=None):\n        \"\"\"Runs publish in an opened host with a context.\n\n        Close Python process at the end.\n        \"\"\"\n\n        from ayon_aftereffects.api.lib import publish_in_test\n\n        publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/index.html#client.ayon_aftereffects.AfterEffectsAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_aftereffects/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"WEBSOCKET_URL\": \"ws://localhost:8097/ws/\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/index.html#client.ayon_aftereffects.AfterEffectsAddon.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Runs publish in an opened host with a context.</p> <p>Close Python process at the end.</p> Source code in <code>client/ayon_aftereffects/addon.py</code> <pre><code>def publish_in_test(self, log, close_plugin_name=None):\n    \"\"\"Runs publish in an opened host with a context.\n\n    Close Python process at the end.\n    \"\"\"\n\n    from ayon_aftereffects.api.lib import publish_in_test\n\n    publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_aftereffects/addon.html#client.ayon_aftereffects.addon.AfterEffectsAddon","title":"<code>AfterEffectsAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_aftereffects/addon.py</code> <pre><code>class AfterEffectsAddon(AYONAddon, IHostAddon):\n    name = \"aftereffects\"\n    version = __version__\n    host_name = \"aftereffects\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"WEBSOCKET_URL\": \"ws://localhost:8097/ws/\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_workfile_extensions(self):\n        return [\".aep\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(AFTEREFFECTS_ADDON_ROOT, \"hooks\")\n        ]\n\n    def publish_in_test(self, log, close_plugin_name=None):\n        \"\"\"Runs publish in an opened host with a context.\n\n        Close Python process at the end.\n        \"\"\"\n\n        from ayon_aftereffects.api.lib import publish_in_test\n\n        publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/addon.html#client.ayon_aftereffects.addon.AfterEffectsAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_aftereffects/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"WEBSOCKET_URL\": \"ws://localhost:8097/ws/\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/addon.html#client.ayon_aftereffects.addon.AfterEffectsAddon.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Runs publish in an opened host with a context.</p> <p>Close Python process at the end.</p> Source code in <code>client/ayon_aftereffects/addon.py</code> <pre><code>def publish_in_test(self, log, close_plugin_name=None):\n    \"\"\"Runs publish in an opened host with a context.\n\n    Close Python process at the end.\n    \"\"\"\n\n    from ayon_aftereffects.api.lib import publish_in_test\n\n    publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/version.html","title":"version","text":"<p>Package declaring AYON addon 'aftereffects' version.</p>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.AfterEffectsHost","title":"<code>AfterEffectsHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>class AfterEffectsHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"aftereffects\"\n\n    def __init__(self):\n        self._stub = None\n        super(AfterEffectsHost, self).__init__()\n\n    @property\n    def stub(self):\n        \"\"\"\n            Handle pulling stub from PS to run operations on host\n        Returns:\n            (AEServerStub) or None\n        \"\"\"\n        if self._stub:\n            return self._stub\n\n        try:\n            stub = get_stub()  # only after Photoshop is up\n        except ConnectionNotEstablishedYet:\n            print(\"Not connected yet, ignoring\")\n            return\n\n        self._stub = stub\n        return self._stub\n\n    def install(self):\n        print(\"Installing AYON After Effects integration...\")\n\n        pyblish.api.register_host(\"aftereffects\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def get_workfile_extensions(self):\n        return [\".aep\"]\n\n    def save_workfile(self, dst_path=None):\n        self.stub.saveAs(dst_path, True)\n\n    def open_workfile(self, filepath):\n        self.stub.open(filepath)\n\n        return True\n\n    def get_current_workfile(self):\n        try:\n            full_name = get_stub().get_active_document_full_name()\n            if full_name and full_name != \"null\":\n                return os.path.normpath(full_name).replace(\"\\\\\", \"/\")\n        except ValueError:\n            print(\"Nothing opened\")\n            pass\n\n        return None\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        meta = self.stub.get_metadata()\n        for item in meta:\n            if item.get(\"id\") == \"publish_context\":\n                item.pop(\"id\")\n                return item\n\n        return {}\n\n    def update_context_data(self, data, changes):\n        item = data\n        item[\"id\"] = \"publish_context\"\n        self.stub.imprint(item[\"id\"], item)\n\n    # created instances section\n    def list_instances(self):\n        \"\"\"List all created instances from current workfile which\n        will be published.\n\n        Pulls from File &gt; File Info\n\n        For Scene Inventory (Manage...)\n\n        Returns:\n            (list) of dictionaries matching instances format\n        \"\"\"\n        stub = self.stub\n        if not stub:\n            return []\n\n        instances = []\n        layers_meta = stub.get_metadata()\n\n        for instance in layers_meta:\n            if instance.get(\"id\") in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                instances.append(instance)\n        return instances\n\n    def remove_instance(self, instance):\n        \"\"\"Remove instance from current workfile metadata.\n\n        Updates metadata of current file in File &gt; File Info and removes\n        icon highlight on group layer.\n\n        For Scene Inventory\n\n        Args:\n            instance (dict): instance representation from Scene Inventory model\n        \"\"\"\n        stub = self.stub\n\n        if not stub:\n            return\n\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n        if not inst_id:\n            log.warning(\"No instance identifier for {}\".format(instance))\n            return\n\n        stub.remove_instance(inst_id)\n\n        if instance.get(\"members\"):\n            item = stub.get_item(instance[\"members\"][0])\n            if item:\n                stub.rename_item(item.id,\n                                 item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.AfterEffectsHost.stub","title":"<code>stub</code>  <code>property</code>","text":"<pre><code>Handle pulling stub from PS to run operations on host\n</code></pre> <p>Returns:     (AEServerStub) or None</p>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.AfterEffectsHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile which will be published.</p> <p>Pulls from File &gt; File Info</p> <p>For Scene Inventory (Manage...)</p> <p>Returns:</p> Type Description <p>(list) of dictionaries matching instances format</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances from current workfile which\n    will be published.\n\n    Pulls from File &gt; File Info\n\n    For Scene Inventory (Manage...)\n\n    Returns:\n        (list) of dictionaries matching instances format\n    \"\"\"\n    stub = self.stub\n    if not stub:\n        return []\n\n    instances = []\n    layers_meta = stub.get_metadata()\n\n    for instance in layers_meta:\n        if instance.get(\"id\") in {\n            AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n        }:\n            instances.append(instance)\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.AfterEffectsHost.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance from current workfile metadata.</p> <p>Updates metadata of current file in File &gt; File Info and removes icon highlight on group layer.</p> <p>For Scene Inventory</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>dict</code> <p>instance representation from Scene Inventory model</p> required Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def remove_instance(self, instance):\n    \"\"\"Remove instance from current workfile metadata.\n\n    Updates metadata of current file in File &gt; File Info and removes\n    icon highlight on group layer.\n\n    For Scene Inventory\n\n    Args:\n        instance (dict): instance representation from Scene Inventory model\n    \"\"\"\n    stub = self.stub\n\n    if not stub:\n        return\n\n    inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n    if not inst_id:\n        log.warning(\"No instance identifier for {}\".format(instance))\n        return\n\n    stub.remove_instance(inst_id)\n\n    if instance.get(\"members\"):\n        item = stub.get_item(instance[\"members\"][0])\n        if item:\n            stub.rename_item(item.id,\n                             item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.containerise","title":"<code>containerise(name, namespace, comp, context, loader=None, suffix='_CON')</code>","text":"<p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Creates dictionary payloads that gets saved into file metadata. Each container contains of who loaded (loader) and members (single or multiple in case of background).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>comp</code> <code>AEItem</code> <p>Composition to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'_CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 comp,\n                 context,\n                 loader=None,\n                 suffix=\"_CON\"):\n    \"\"\"\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Creates dictionary payloads that gets saved into file metadata. Each\n    container contains of who loaded (loader) and members (single or multiple\n    in case of background).\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        comp (AEItem): Composition to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n    \"\"\"\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"members\": comp.members or [comp.id]\n    }\n\n    stub = get_stub()\n    stub.imprint(comp.id, data)\n\n    return comp\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.get_entity_attributes","title":"<code>get_entity_attributes(entity)</code>","text":"<p>Get attributes of folder or task entity.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Union[float, int]]</code> <p>Scene data.</p> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>def get_entity_attributes(entity: dict) -&gt; dict[str, Union[float, int]]:\n    \"\"\"Get attributes of folder or task entity.\n\n    Returns:\n        dict: Scene data.\n\n    \"\"\"\n    attrib: dict = entity[\"attrib\"]\n    fps = attrib.get(\"fps\", 0)\n    frame_start = attrib.get(\"frameStart\", 0)\n    frame_end = attrib.get(\"frameEnd\", 0)\n    handle_start = attrib.get(\"handleStart\", 0)\n    handle_end = attrib.get(\"handleEnd\", 0)\n    resolution_width = attrib.get(\"resolutionWidth\", 0)\n    resolution_height = attrib.get(\"resolutionHeight\", 0)\n    duration = (frame_end - frame_start + 1) + handle_start + handle_end\n\n    return {\n        \"fps\": fps,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"resolutionWidth\": resolution_width,\n        \"resolutionHeight\": resolution_height,\n        \"duration\": duration\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.get_stub","title":"<code>get_stub()</code>","text":"<pre><code>Convenience function to get server RPC stub to call methods directed\nfor host (Photoshop).\nIt expects already created connection, started from client.\nCurrently, created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n</code></pre> <p>:return:  where functions could be called from Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_stub():\n    \"\"\"\n        Convenience function to get server RPC stub to call methods directed\n        for host (Photoshop).\n        It expects already created connection, started from client.\n        Currently, created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n    :return: &lt;PhotoshopClientStub&gt; where functions could be called from\n    \"\"\"\n    ae_stub = AfterEffectsServerStub()\n    if not ae_stub.client:\n        raise ConnectionNotEstablishedYet(\"Connection is not created yet\")\n\n    return ae_stub\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active AfterEffects document.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in AE; once loaded they are called 'containers'. Used in Manage tool.</p> <p>Containers could be on multiple levels, single images/videos/was as a FootageItem, or multiple items - backgrounds (folder with automatically created composition and all imported layers).</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active AfterEffects document.\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in AE; once loaded\n    they are called 'containers'. Used in Manage tool.\n\n    Containers could be on multiple levels, single images/videos/was as a\n    FootageItem, or multiple items - backgrounds (folder with automatically\n    created composition and all imported layers).\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    try:\n        stub = get_stub()  # only after AfterEffects is up\n    except ConnectionNotEstablishedYet:\n        print(\"Not connected yet, ignoring\")\n        return\n\n    layers_meta = stub.get_metadata()\n    for item in stub.get_items(comps=True,\n                               folders=True,\n                               footages=True):\n        data = stub.read(item, layers_meta)\n        # Skip non-tagged layers.\n        if not data:\n            continue\n\n        # Filter to only containers.\n        if \"container\" not in data[\"id\"]:\n            continue\n\n        # Append transient data\n        data[\"objectName\"] = item.name.replace(stub.LOADED_ICON, '')\n        data[\"layer\"] = item\n        yield data\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n    selection = get_stub().get_selected_items(True, False, False)\n    try:\n        yield selection\n    finally:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/index.html#client.ayon_aftereffects.api.set_settings","title":"<code>set_settings(frames, resolution, comp_ids=None, print_msg=True, entity=None)</code>","text":"<p>Sets number of frames and resolution to selected comps.</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>bool</code> <p>True if set frame info</p> required <code>resolution</code> <code>bool</code> <p>True if set resolution</p> required <code>comp_ids</code> <code>list[int]</code> <p>specific composition ids, if empty it tries to look for currently selected</p> <code>None</code> <code>print_msg</code> <code>bool</code> <p>True throw JS alert with msg</p> <code>True</code> <code>entity</code> <code>Optional[dict]</code> <p>Entity to use attributes from to define the frame range, fps and resolution from. If not provided, current task entity is used.</p> <code>None</code> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>def set_settings(\n        frames, resolution, comp_ids=None, print_msg=True, entity=None):\n    \"\"\"Sets number of frames and resolution to selected comps.\n\n    Args:\n        frames (bool): True if set frame info\n        resolution (bool): True if set resolution\n        comp_ids (list[int]): specific composition ids, if empty\n            it tries to look for currently selected\n        print_msg (bool): True throw JS alert with msg\n        entity (Optional[dict]): Entity to use attributes from to define the\n            frame range, fps and resolution from. If not provided, current\n            task entity is used.\n    \"\"\"\n    frame_start = frames_duration = fps = width = height = None\n\n    if entity is None:\n        entity = get_current_task_entity()\n    settings = get_entity_attributes(entity)\n\n    msg = ''\n    if frames:\n        frame_start = settings[\"frameStart\"] - settings[\"handleStart\"]\n        frames_duration = settings[\"duration\"]\n        fps = settings[\"fps\"]\n        msg += f\"frame start:{frame_start}, duration:{frames_duration}, \"\\\n               f\"fps:{fps}\"\n    if resolution:\n        width = settings[\"resolutionWidth\"]\n        height = settings[\"resolutionHeight\"]\n        msg += f\"width:{width} and height:{height}\"\n\n    stub = get_stub()\n    if not comp_ids:\n        comps = stub.get_selected_items(True, False, False)\n        comp_ids = [comp.id for comp in comps]\n    if not comp_ids:\n        stub.print_msg(\"Select at least one composition to apply settings.\")\n        return\n\n    for comp_id in comp_ids:\n        msg = f\"Setting for comp {comp_id} \" + msg\n        log.debug(msg)\n        stub.set_comp_properties(comp_id, frame_start, frames_duration,\n                                 fps, width, height)\n        if print_msg:\n            stub.print_msg(msg)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_logic.html","title":"launch_logic","text":""},{"location":"autoapi/client/ayon_aftereffects/api/launch_logic.html#client.ayon_aftereffects.api.launch_logic.AfterEffectsRoute","title":"<code>AfterEffectsRoute</code>","text":"<p>               Bases: <code>WebSocketRoute</code></p> <p>One route, mimicking external application (like Harmony, etc). All functions could be called from client. 'do_notify' function calls function on the client - mimicking     notification after long running job on the server or similar</p> Source code in <code>client/ayon_aftereffects/api/launch_logic.py</code> <pre><code>class AfterEffectsRoute(WebSocketRoute):\n    \"\"\"\n        One route, mimicking external application (like Harmony, etc).\n        All functions could be called from client.\n        'do_notify' function calls function on the client - mimicking\n            notification after long running job on the server or similar\n    \"\"\"\n    instance = None\n\n    def init(self, **kwargs):\n        # Python __init__ must be return \"self\".\n        # This method might return anything.\n        log.debug(\"someone called AfterEffects route\")\n        self.instance = self\n        return kwargs\n\n    # server functions\n    async def ping(self):\n        log.debug(\"someone called AfterEffects route ping\")\n\n    # This method calls function on the client side\n    # client functions\n    async def set_context(self, project, folder, task):\n        \"\"\"\n            Sets 'project', 'folder' and 'task' to envs, eg. setting context\n\n            Args:\n                project (str)\n                folder (str)\n                task (str)\n        \"\"\"\n        log.info(\"Setting context change\")\n        log.info(\"project {} folder {} \".format(project, folder))\n        if project:\n            os.environ[\"AYON_PROJECT_NAME\"] = project\n        if folder:\n            os.environ[\"AYON_FOLDER_PATH\"] = folder\n        if task:\n            os.environ[\"AYON_TASK_NAME\"] = task\n\n    async def read(self):\n        log.debug(\"aftereffects.read client calls server server calls \"\n                  \"aftereffects client\")\n        return await self.socket.call('aftereffects.read')\n\n    # panel routes for tools\n    async def workfiles_route(self):\n        self._tool_route(\"workfiles\")\n\n    async def loader_route(self):\n        self._tool_route(\"loader\")\n\n    async def publish_route(self):\n        self._tool_route(\"publisher\")\n\n    async def sceneinventory_route(self):\n        self._tool_route(\"sceneinventory\")\n\n    async def setresolution_route(self):\n        self._settings_route(False, True)\n\n    async def setframes_route(self):\n        self._settings_route(True, False)\n\n    async def setall_route(self):\n        self._settings_route(True, True)\n\n    async def experimental_tools_route(self):\n        self._tool_route(\"experimental_tools\")\n\n    def _tool_route(self, _tool_name):\n        \"\"\"The address accessed when clicking on the buttons.\"\"\"\n\n        partial_method = functools.partial(show_tool_by_name,\n                                           _tool_name)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def _settings_route(self, frames, resolution):\n        partial_method = functools.partial(set_settings,\n                                           frames,\n                                           resolution)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def create_placeholder_route(self):\n        from ayon_aftereffects.api.workfile_template_builder import \\\n            create_placeholder\n        partial_method = functools.partial(create_placeholder)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def update_placeholder_route(self):\n        from ayon_aftereffects.api.workfile_template_builder import \\\n            update_placeholder\n        partial_method = functools.partial(update_placeholder)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def build_workfile_template_route(self):\n        from ayon_aftereffects.api.workfile_template_builder import \\\n            build_workfile_template\n        partial_method = functools.partial(build_workfile_template)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_logic.html#client.ayon_aftereffects.api.launch_logic.AfterEffectsRoute.set_context","title":"<code>set_context(project, folder, task)</code>  <code>async</code>","text":"<p>Sets 'project', 'folder' and 'task' to envs, eg. setting context</p> Source code in <code>client/ayon_aftereffects/api/launch_logic.py</code> <pre><code>async def set_context(self, project, folder, task):\n    \"\"\"\n        Sets 'project', 'folder' and 'task' to envs, eg. setting context\n\n        Args:\n            project (str)\n            folder (str)\n            task (str)\n    \"\"\"\n    log.info(\"Setting context change\")\n    log.info(\"project {} folder {} \".format(project, folder))\n    if project:\n        os.environ[\"AYON_PROJECT_NAME\"] = project\n    if folder:\n        os.environ[\"AYON_FOLDER_PATH\"] = folder\n    if task:\n        os.environ[\"AYON_TASK_NAME\"] = task\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_logic.html#client.ayon_aftereffects.api.launch_logic.ProcessLauncher","title":"<code>ProcessLauncher</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Launches webserver, connects to it, runs main thread.</p> Source code in <code>client/ayon_aftereffects/api/launch_logic.py</code> <pre><code>class ProcessLauncher(QtCore.QObject):\n    \"\"\"Launches webserver, connects to it, runs main thread.\"\"\"\n    route_name = \"AfterEffects\"\n    _main_thread_callbacks = collections.deque()\n\n    def __init__(self, subprocess_args):\n        self._subprocess_args = subprocess_args\n        self._log = None\n\n        super(ProcessLauncher, self).__init__()\n\n        # Keep track if launcher was alreadu started\n        self._started = False\n\n        self._process = None\n        self._websocket_server = None\n\n        start_process_timer = QtCore.QTimer()\n        start_process_timer.setInterval(100)\n\n        loop_timer = QtCore.QTimer()\n        loop_timer.setInterval(200)\n\n        start_process_timer.timeout.connect(self._on_start_process_timer)\n        loop_timer.timeout.connect(self._on_loop_timer)\n\n        self._start_process_timer = start_process_timer\n        self._loop_timer = loop_timer\n\n    @property\n    def log(self):\n        if self._log is None:\n            self._log = Logger.get_logger(\"{}-launcher\".format(\n                self.route_name))\n        return self._log\n\n    @property\n    def websocket_server_is_running(self):\n        if self._websocket_server is not None:\n            return self._websocket_server.is_running\n        return False\n\n    @property\n    def is_process_running(self):\n        if self._process is not None:\n            return self._process.poll() is None\n        return False\n\n    @property\n    def is_host_connected(self):\n        \"\"\"Returns True if connected, False if app is not running at all.\"\"\"\n        if not self.is_process_running:\n            return False\n\n        try:\n\n            _stub = get_stub()\n            if _stub:\n                return True\n        except Exception:\n            pass\n\n        return None\n\n    @classmethod\n    def execute_in_main_thread(cls, callback):\n        cls._main_thread_callbacks.append(callback)\n\n    def start(self):\n        if self._started:\n            return\n        self.log.info(\"Started launch logic of AfterEffects\")\n        self._started = True\n        self._start_process_timer.start()\n\n    def exit(self):\n        \"\"\" Exit whole application. \"\"\"\n        if self._start_process_timer.isActive():\n            self._start_process_timer.stop()\n        if self._loop_timer.isActive():\n            self._loop_timer.stop()\n\n        if self._websocket_server is not None:\n            self._websocket_server.stop()\n\n        if self._process:\n            self._process.kill()\n            self._process.wait()\n\n        QtCore.QCoreApplication.exit()\n\n    def _on_loop_timer(self):\n        # TODO find better way and catch errors\n        # Run only callbacks that are in queue at the moment\n        cls = self.__class__\n        for _ in range(len(cls._main_thread_callbacks)):\n            if cls._main_thread_callbacks:\n                callback = cls._main_thread_callbacks.popleft()\n                callback()\n\n        if not self.is_process_running:\n            self.log.info(\"Host process is not running. Closing\")\n            self.exit()\n\n        elif not self.websocket_server_is_running:\n            self.log.info(\"Websocket server is not running. Closing\")\n            self.exit()\n\n    def _on_start_process_timer(self):\n        # TODO add try except validations for each part in this method\n        # Start server as first thing\n        if self._websocket_server is None:\n            self._init_server()\n            return\n\n        # TODO add waiting time\n        # Wait for webserver\n        if not self.websocket_server_is_running:\n            return\n\n        # Start application process\n        if self._process is None:\n            self._start_process()\n            self.log.info(\"Waiting for host to connect\")\n            return\n\n        # TODO add waiting time\n        # Wait until host is connected\n        if self.is_host_connected:\n            self._start_process_timer.stop()\n            self._loop_timer.start()\n        elif (\n            not self.is_process_running\n            or not self.websocket_server_is_running\n        ):\n            self.exit()\n\n    def _init_server(self):\n        if self._websocket_server is not None:\n            return\n\n        self.log.debug(\n            \"Initialization of websocket server for host communication\"\n        )\n\n        self._websocket_server = websocket_server = WebServerTool()\n        if websocket_server.port_occupied(\n            websocket_server.host_name,\n            websocket_server.port\n        ):\n            self.log.info(\n                \"Server already running, sending actual context and exit.\"\n            )\n            asyncio.run(websocket_server.send_context_change(self.route_name))\n            self.exit()\n            return\n\n        # Add Websocket route\n        websocket_server.add_route(\"*\", \"/ws/\", WebSocketAsync)\n        # Add after effects route to websocket handler\n\n        print(\"Adding {} route\".format(self.route_name))\n        WebSocketAsync.add_route(\n            self.route_name, AfterEffectsRoute\n        )\n        self.log.info(\"Starting websocket server for host communication\")\n        websocket_server.start_server()\n\n    def _start_process(self):\n        if self._process is not None:\n            return\n        self.log.info(\"Starting host process\")\n        try:\n            self._process = subprocess.Popen(\n                self._subprocess_args,\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL\n            )\n        except Exception:\n            self.log.info(\"exce\", exc_info=True)\n            self.exit()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_logic.html#client.ayon_aftereffects.api.launch_logic.ProcessLauncher.is_host_connected","title":"<code>is_host_connected</code>  <code>property</code>","text":"<p>Returns True if connected, False if app is not running at all.</p>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_logic.html#client.ayon_aftereffects.api.launch_logic.ProcessLauncher.exit","title":"<code>exit()</code>","text":"<p>Exit whole application.</p> Source code in <code>client/ayon_aftereffects/api/launch_logic.py</code> <pre><code>def exit(self):\n    \"\"\" Exit whole application. \"\"\"\n    if self._start_process_timer.isActive():\n        self._start_process_timer.stop()\n    if self._loop_timer.isActive():\n        self._loop_timer.stop()\n\n    if self._websocket_server is not None:\n        self._websocket_server.stop()\n\n    if self._process:\n        self._process.kill()\n        self._process.wait()\n\n    QtCore.QCoreApplication.exit()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_logic.html#client.ayon_aftereffects.api.launch_logic.main","title":"<code>main(*subprocess_args)</code>","text":"<p>Main entrypoint to AE launching, called from pre hook.</p> Source code in <code>client/ayon_aftereffects/api/launch_logic.py</code> <pre><code>def main(*subprocess_args):\n    \"\"\"Main entrypoint to AE launching, called from pre hook.\"\"\"\n    sys.excepthook = safe_excepthook\n\n    from ayon_aftereffects.api import AfterEffectsHost\n\n    host = AfterEffectsHost()\n    install_host(host)\n\n    os.environ[\"AYON_LOG_NO_COLORS\"] = \"0\"\n    app = get_ayon_qt_app()\n    app.setQuitOnLastWindowClosed(False)\n\n    launcher = ProcessLauncher(subprocess_args)\n    launcher.start()\n\n    workfiles_on_launch = os.getenv(\n        \"AYON_AFTEREFFECTS_WORKFILES_ON_LAUNCH\",\n        # Backwards compatibility\n        os.getenv(\"AVALON_AFTEREFFECTS_WORKFILES_ON_LAUNCH\", True)\n    )\n\n    if is_in_tests():\n        manager = AddonsManager()\n        aftereffects_addon = manager[\"aftereffects\"]\n\n        launcher.execute_in_main_thread(\n            functools.partial(\n                aftereffects_addon.publish_in_test,\n                log,\n                \"CloseAE\",\n            )\n        )\n\n    elif workfiles_on_launch:\n        save = False\n        if os.getenv(\"WORKFILES_SAVE_AS\"):\n            save = True\n\n        launcher.execute_in_main_thread(\n            lambda: host_tools.show_tool_by_name(\"workfiles\", save=save)\n        )\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_script.html","title":"launch_script","text":"<p>Script wraps launch mechanism of AfterEffects implementations.</p> <p>Arguments passed to the script are passed to launch function in host implementation. In all cases requires host app executable and may contain workfile or others.</p>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_script.html#client.ayon_aftereffects.api.launch_script.on_invalid_args","title":"<code>on_invalid_args(script_not_found)</code>","text":"<p>Show to user message box saying that something went wrong.</p> <p>Tell user that arguments to launch implementation are invalid with arguments details.</p> <p>Parameters:</p> Name Type Description Default <code>script_not_found</code> <code>bool</code> <p>Use different message based on this value.</p> required Source code in <code>client/ayon_aftereffects/api/launch_script.py</code> <pre><code>def on_invalid_args(script_not_found):\n    \"\"\"Show to user message box saying that something went wrong.\n\n    Tell user that arguments to launch implementation are invalid with\n    arguments details.\n\n    Args:\n        script_not_found (bool): Use different message based on this value.\n    \"\"\"\n\n    title = \"Invalid arguments\"\n    joined_args = \", \".join(\"\\\"{}\\\"\".format(arg) for arg in sys.argv)\n    if script_not_found:\n        submsg = \"Where couldn't find script path:\\n\\\"{}\\\"\"\n    else:\n        submsg = \"Expected Host executable after script path:\\n\\\"{}\\\"\"\n\n    message = \"BUG: Got invalid arguments so can't launch Host application.\"\n    detail_message = \"Process was launched with arguments:\\n{}\\n\\n{}\".format(\n        joined_args,\n        submsg.format(CURRENT_FILE)\n    )\n\n    show_error_messagebox(title, message, detail_message)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/launch_script.html#client.ayon_aftereffects.api.launch_script.show_error_messagebox","title":"<code>show_error_messagebox(title, message, detail_message=None)</code>","text":"<p>Function will show message and process ends after closing it.</p> Source code in <code>client/ayon_aftereffects/api/launch_script.py</code> <pre><code>def show_error_messagebox(title, message, detail_message=None):\n    \"\"\"Function will show message and process ends after closing it.\"\"\"\n    from qtpy import QtWidgets, QtCore\n    from ayon_core import style\n\n    app = QtWidgets.QApplication([])\n    app.setStyleSheet(style.load_stylesheet())\n\n    msgbox = QtWidgets.QMessageBox()\n    msgbox.setWindowTitle(title)\n    msgbox.setText(message)\n\n    if detail_message:\n        msgbox.setDetailedText(detail_message)\n\n    msgbox.setWindowModality(QtCore.Qt.ApplicationModal)\n    msgbox.show()\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_aftereffects/api/lib.html#client.ayon_aftereffects.api.lib.get_background_layers","title":"<code>get_background_layers(file_url)</code>","text":"<p>Pulls file name from background json file, enrich with folder url for AE to be able import files.</p> <p>Order is important, follows order in json.</p> <p>Parameters:</p> Name Type Description Default <code>file_url</code> <code>str</code> <p>abs url of background json</p> required <p>Returns:</p> Type Description <code>list</code> <p>of abs paths to images</p> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>def get_background_layers(file_url):\n    \"\"\"\n        Pulls file name from background json file, enrich with folder url for\n        AE to be able import files.\n\n        Order is important, follows order in json.\n\n        Args:\n            file_url (str): abs url of background json\n\n        Returns:\n            (list): of abs paths to images\n    \"\"\"\n    with open(file_url) as json_file:\n        data = json.load(json_file)\n\n    layers = list()\n    bg_folder = os.path.dirname(file_url)\n    for child in data['children']:\n        if child.get(\"filename\"):\n            layers.append(os.path.join(bg_folder, child.get(\"filename\")).\n                          replace(\"\\\\\", \"/\"))\n        else:\n            for layer in child['children']:\n                if layer.get(\"filename\"):\n                    layers.append(os.path.join(bg_folder,\n                                               layer.get(\"filename\")).\n                                  replace(\"\\\\\", \"/\"))\n    return layers\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/lib.html#client.ayon_aftereffects.api.lib.get_entity_attributes","title":"<code>get_entity_attributes(entity)</code>","text":"<p>Get attributes of folder or task entity.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Union[float, int]]</code> <p>Scene data.</p> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>def get_entity_attributes(entity: dict) -&gt; dict[str, Union[float, int]]:\n    \"\"\"Get attributes of folder or task entity.\n\n    Returns:\n        dict: Scene data.\n\n    \"\"\"\n    attrib: dict = entity[\"attrib\"]\n    fps = attrib.get(\"fps\", 0)\n    frame_start = attrib.get(\"frameStart\", 0)\n    frame_end = attrib.get(\"frameEnd\", 0)\n    handle_start = attrib.get(\"handleStart\", 0)\n    handle_end = attrib.get(\"handleEnd\", 0)\n    resolution_width = attrib.get(\"resolutionWidth\", 0)\n    resolution_height = attrib.get(\"resolutionHeight\", 0)\n    duration = (frame_end - frame_start + 1) + handle_start + handle_end\n\n    return {\n        \"fps\": fps,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"resolutionWidth\": resolution_width,\n        \"resolutionHeight\": resolution_height,\n        \"duration\": duration\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/lib.html#client.ayon_aftereffects.api.lib.get_unique_layer_name","title":"<code>get_unique_layer_name(layers, name)</code>","text":"<pre><code>Gets all layer names and if 'name' is present in them, increases\nsuffix by 1 (eg. creates unique layer name - for Loader)\n</code></pre> <p>Args:     layers (list): of strings, names only     name (string):  checked value</p> <p>Returns:</p> Type Description <code>string</code> <p>name_00X (without version)</p> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>def get_unique_layer_name(layers, name):\n    \"\"\"\n        Gets all layer names and if 'name' is present in them, increases\n        suffix by 1 (eg. creates unique layer name - for Loader)\n    Args:\n        layers (list): of strings, names only\n        name (string):  checked value\n\n    Returns:\n        (string): name_00X (without version)\n    \"\"\"\n    names = {}\n    for layer in layers:\n        layer_name = re.sub(r'_\\d{3}$', '', layer)\n        if layer_name in names.keys():\n            names[layer_name] = names[layer_name] + 1\n        else:\n            names[layer_name] = 1\n    occurrences = names.get(name, 0)\n\n    return \"{}_{:0&gt;3d}\".format(name, occurrences + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/lib.html#client.ayon_aftereffects.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n    selection = get_stub().get_selected_items(True, False, False)\n    try:\n        yield selection\n    finally:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/lib.html#client.ayon_aftereffects.api.lib.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Loops through all plugins, logs to console. Used for tests.</p> <p>Parameters:</p> Name Type Description Default <code>close_plugin_name</code> <code>Optional[str]</code> <p>Name of plugin with responsibility to close application.</p> <code>None</code> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>def publish_in_test(log, close_plugin_name=None):\n    \"\"\"Loops through all plugins, logs to console. Used for tests.\n\n    Args:\n        log (Logger)\n        close_plugin_name (Optional[str]): Name of plugin with responsibility\n            to close application.\n    \"\"\"\n\n    # Error exit as soon as any error occurs.\n    error_format = \"Failed {plugin.__name__}: {error} -- {error.traceback}\"\n    close_plugin = find_close_plugin(close_plugin_name, log)\n\n    for result in pyblish.util.publish_iter():\n        for record in result[\"records\"]:\n            # Why do we log again? pyblish logger is logging to stdout...\n            log.info(\"{}: {}\".format(result[\"plugin\"].label, record.msg))\n\n        if not result[\"error\"]:\n            continue\n\n        # QUESTION We don't break on error?\n        error_message = error_format.format(**result)\n        log.error(error_message)\n        if close_plugin:  # close host app explicitly after error\n            context = pyblish.api.Context()\n            try:\n                close_plugin().process(context)\n            except Exception as exp:\n                print(exp)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/lib.html#client.ayon_aftereffects.api.lib.set_settings","title":"<code>set_settings(frames, resolution, comp_ids=None, print_msg=True, entity=None)</code>","text":"<p>Sets number of frames and resolution to selected comps.</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>bool</code> <p>True if set frame info</p> required <code>resolution</code> <code>bool</code> <p>True if set resolution</p> required <code>comp_ids</code> <code>list[int]</code> <p>specific composition ids, if empty it tries to look for currently selected</p> <code>None</code> <code>print_msg</code> <code>bool</code> <p>True throw JS alert with msg</p> <code>True</code> <code>entity</code> <code>Optional[dict]</code> <p>Entity to use attributes from to define the frame range, fps and resolution from. If not provided, current task entity is used.</p> <code>None</code> Source code in <code>client/ayon_aftereffects/api/lib.py</code> <pre><code>def set_settings(\n        frames, resolution, comp_ids=None, print_msg=True, entity=None):\n    \"\"\"Sets number of frames and resolution to selected comps.\n\n    Args:\n        frames (bool): True if set frame info\n        resolution (bool): True if set resolution\n        comp_ids (list[int]): specific composition ids, if empty\n            it tries to look for currently selected\n        print_msg (bool): True throw JS alert with msg\n        entity (Optional[dict]): Entity to use attributes from to define the\n            frame range, fps and resolution from. If not provided, current\n            task entity is used.\n    \"\"\"\n    frame_start = frames_duration = fps = width = height = None\n\n    if entity is None:\n        entity = get_current_task_entity()\n    settings = get_entity_attributes(entity)\n\n    msg = ''\n    if frames:\n        frame_start = settings[\"frameStart\"] - settings[\"handleStart\"]\n        frames_duration = settings[\"duration\"]\n        fps = settings[\"fps\"]\n        msg += f\"frame start:{frame_start}, duration:{frames_duration}, \"\\\n               f\"fps:{fps}\"\n    if resolution:\n        width = settings[\"resolutionWidth\"]\n        height = settings[\"resolutionHeight\"]\n        msg += f\"width:{width} and height:{height}\"\n\n    stub = get_stub()\n    if not comp_ids:\n        comps = stub.get_selected_items(True, False, False)\n        comp_ids = [comp.id for comp in comps]\n    if not comp_ids:\n        stub.print_msg(\"Select at least one composition to apply settings.\")\n        return\n\n    for comp_id in comp_ids:\n        msg = f\"Setting for comp {comp_id} \" + msg\n        log.debug(msg)\n        stub.set_comp_properties(comp_id, frame_start, frames_duration,\n                                 fps, width, height)\n        if print_msg:\n            stub.print_msg(msg)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.AfterEffectsHost","title":"<code>AfterEffectsHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>class AfterEffectsHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"aftereffects\"\n\n    def __init__(self):\n        self._stub = None\n        super(AfterEffectsHost, self).__init__()\n\n    @property\n    def stub(self):\n        \"\"\"\n            Handle pulling stub from PS to run operations on host\n        Returns:\n            (AEServerStub) or None\n        \"\"\"\n        if self._stub:\n            return self._stub\n\n        try:\n            stub = get_stub()  # only after Photoshop is up\n        except ConnectionNotEstablishedYet:\n            print(\"Not connected yet, ignoring\")\n            return\n\n        self._stub = stub\n        return self._stub\n\n    def install(self):\n        print(\"Installing AYON After Effects integration...\")\n\n        pyblish.api.register_host(\"aftereffects\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def get_workfile_extensions(self):\n        return [\".aep\"]\n\n    def save_workfile(self, dst_path=None):\n        self.stub.saveAs(dst_path, True)\n\n    def open_workfile(self, filepath):\n        self.stub.open(filepath)\n\n        return True\n\n    def get_current_workfile(self):\n        try:\n            full_name = get_stub().get_active_document_full_name()\n            if full_name and full_name != \"null\":\n                return os.path.normpath(full_name).replace(\"\\\\\", \"/\")\n        except ValueError:\n            print(\"Nothing opened\")\n            pass\n\n        return None\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        meta = self.stub.get_metadata()\n        for item in meta:\n            if item.get(\"id\") == \"publish_context\":\n                item.pop(\"id\")\n                return item\n\n        return {}\n\n    def update_context_data(self, data, changes):\n        item = data\n        item[\"id\"] = \"publish_context\"\n        self.stub.imprint(item[\"id\"], item)\n\n    # created instances section\n    def list_instances(self):\n        \"\"\"List all created instances from current workfile which\n        will be published.\n\n        Pulls from File &gt; File Info\n\n        For Scene Inventory (Manage...)\n\n        Returns:\n            (list) of dictionaries matching instances format\n        \"\"\"\n        stub = self.stub\n        if not stub:\n            return []\n\n        instances = []\n        layers_meta = stub.get_metadata()\n\n        for instance in layers_meta:\n            if instance.get(\"id\") in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                instances.append(instance)\n        return instances\n\n    def remove_instance(self, instance):\n        \"\"\"Remove instance from current workfile metadata.\n\n        Updates metadata of current file in File &gt; File Info and removes\n        icon highlight on group layer.\n\n        For Scene Inventory\n\n        Args:\n            instance (dict): instance representation from Scene Inventory model\n        \"\"\"\n        stub = self.stub\n\n        if not stub:\n            return\n\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n        if not inst_id:\n            log.warning(\"No instance identifier for {}\".format(instance))\n            return\n\n        stub.remove_instance(inst_id)\n\n        if instance.get(\"members\"):\n            item = stub.get_item(instance[\"members\"][0])\n            if item:\n                stub.rename_item(item.id,\n                                 item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.AfterEffectsHost.stub","title":"<code>stub</code>  <code>property</code>","text":"<pre><code>Handle pulling stub from PS to run operations on host\n</code></pre> <p>Returns:     (AEServerStub) or None</p>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.AfterEffectsHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile which will be published.</p> <p>Pulls from File &gt; File Info</p> <p>For Scene Inventory (Manage...)</p> <p>Returns:</p> Type Description <p>(list) of dictionaries matching instances format</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances from current workfile which\n    will be published.\n\n    Pulls from File &gt; File Info\n\n    For Scene Inventory (Manage...)\n\n    Returns:\n        (list) of dictionaries matching instances format\n    \"\"\"\n    stub = self.stub\n    if not stub:\n        return []\n\n    instances = []\n    layers_meta = stub.get_metadata()\n\n    for instance in layers_meta:\n        if instance.get(\"id\") in {\n            AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n        }:\n            instances.append(instance)\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.AfterEffectsHost.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance from current workfile metadata.</p> <p>Updates metadata of current file in File &gt; File Info and removes icon highlight on group layer.</p> <p>For Scene Inventory</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>dict</code> <p>instance representation from Scene Inventory model</p> required Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def remove_instance(self, instance):\n    \"\"\"Remove instance from current workfile metadata.\n\n    Updates metadata of current file in File &gt; File Info and removes\n    icon highlight on group layer.\n\n    For Scene Inventory\n\n    Args:\n        instance (dict): instance representation from Scene Inventory model\n    \"\"\"\n    stub = self.stub\n\n    if not stub:\n        return\n\n    inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n    if not inst_id:\n        log.warning(\"No instance identifier for {}\".format(instance))\n        return\n\n    stub.remove_instance(inst_id)\n\n    if instance.get(\"members\"):\n        item = stub.get_item(instance[\"members\"][0])\n        if item:\n            stub.rename_item(item.id,\n                             item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.application_launch","title":"<code>application_launch()</code>","text":"<p>Triggered after start of app</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def application_launch():\n    \"\"\"Triggered after start of app\"\"\"\n    check_inventory()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.cache_and_get_instances","title":"<code>cache_and_get_instances(creator)</code>","text":"<p>Cache instances in shared data.</p> <p>Storing all instances as a list as legacy instances might be still present. Args:     creator (Creator): Plugin which would like to get instances from host. Returns:     List[]: list of all instances stored in metadata</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def cache_and_get_instances(creator):\n    \"\"\"Cache instances in shared data.\n\n    Storing all instances as a list as legacy instances might be still present.\n    Args:\n        creator (Creator): Plugin which would like to get instances from host.\n    Returns:\n        List[]: list of all instances stored in metadata\n    \"\"\"\n    shared_key = \"ayon.aftereffects.instances\"\n    if shared_key not in creator.collection_shared_data:\n        creator.collection_shared_data[shared_key] = \\\n            creator.host.list_instances()\n    return creator.collection_shared_data[shared_key]\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.check_inventory","title":"<code>check_inventory()</code>","text":"<p>Checks loaded containers if they are of highest version</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def check_inventory():\n    \"\"\"Checks loaded containers if they are of highest version\"\"\"\n    if not any_outdated_containers():\n        return\n\n    # Warn about outdated containers.\n    _app = get_ayon_qt_app()\n\n    message_box = QtWidgets.QMessageBox()\n    message_box.setIcon(QtWidgets.QMessageBox.Warning)\n    msg = \"There are outdated containers in the scene.\"\n    message_box.setText(msg)\n    message_box.exec_()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.containerise","title":"<code>containerise(name, namespace, comp, context, loader=None, suffix='_CON')</code>","text":"<p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Creates dictionary payloads that gets saved into file metadata. Each container contains of who loaded (loader) and members (single or multiple in case of background).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>comp</code> <code>AEItem</code> <p>Composition to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>suffix</code> <code>str</code> <p>Suffix of container, defaults to <code>_CON</code>.</p> <code>'_CON'</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def containerise(name,\n                 namespace,\n                 comp,\n                 context,\n                 loader=None,\n                 suffix=\"_CON\"):\n    \"\"\"\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Creates dictionary payloads that gets saved into file metadata. Each\n    container contains of who loaded (loader) and members (single or multiple\n    in case of background).\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        comp (AEItem): Composition to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        suffix (str, optional): Suffix of container, defaults to `_CON`.\n\n    Returns:\n        container (str): Name of container assembly\n    \"\"\"\n    data = {\n        \"schema\": \"ayon:container-3.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"members\": comp.members or [comp.id]\n    }\n\n    stub = get_stub()\n    stub.imprint(comp.id, data)\n\n    return comp\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/pipeline.html#client.ayon_aftereffects.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active AfterEffects document.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in AE; once loaded they are called 'containers'. Used in Manage tool.</p> <p>Containers could be on multiple levels, single images/videos/was as a FootageItem, or multiple items - backgrounds (folder with automatically created composition and all imported layers).</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_aftereffects/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active AfterEffects document.\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in AE; once loaded\n    they are called 'containers'. Used in Manage tool.\n\n    Containers could be on multiple levels, single images/videos/was as a\n    FootageItem, or multiple items - backgrounds (folder with automatically\n    created composition and all imported layers).\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    try:\n        stub = get_stub()  # only after AfterEffects is up\n    except ConnectionNotEstablishedYet:\n        print(\"Not connected yet, ignoring\")\n        return\n\n    layers_meta = stub.get_metadata()\n    for item in stub.get_items(comps=True,\n                               folders=True,\n                               footages=True):\n        data = stub.read(item, layers_meta)\n        # Skip non-tagged layers.\n        if not data:\n            continue\n\n        # Filter to only containers.\n        if \"container\" not in data[\"id\"]:\n            continue\n\n        # Append transient data\n        data[\"objectName\"] = item.name.replace(stub.LOADED_ICON, '')\n        data[\"layer\"] = item\n        yield data\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html","title":"webserver","text":"<p>Webserver for communication with AfterEffects.</p> <p>Aiohttp (Asyncio) based websocket server used for communication with host application.</p> <p>This webserver is started in spawned Python process that opens DCC during its launch, waits for connection from DCC and handles communication going forward. Server is closed before Python process is killed.</p>"},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html#client.ayon_aftereffects.api.webserver.WebServerThread","title":"<code>WebServerThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Listener for websocket rpc requests.</p> <p>It would be probably better to \"attach\" this to main thread (as for example Harmony needs to run something on main thread), but currently it creates separate thread and separate asyncio event loop</p> Source code in <code>client/ayon_aftereffects/api/webserver.py</code> <pre><code>class WebServerThread(threading.Thread):\n    \"\"\" Listener for websocket rpc requests.\n\n        It would be probably better to \"attach\" this to main thread (as for\n        example Harmony needs to run something on main thread), but currently\n        it creates separate thread and separate asyncio event loop\n    \"\"\"\n    def __init__(self, module, port):\n        super(WebServerThread, self).__init__()\n\n        self.is_running = False\n        self.port = port\n        self.module = module\n        self.loop = None\n        self.runner = None\n        self.site = None\n        self.tasks = []\n\n    def run(self):\n        self.is_running = True\n\n        try:\n            log.info(\"Starting web server\")\n            self.loop = asyncio.new_event_loop()  # create new loop for thread\n            asyncio.set_event_loop(self.loop)\n\n            self.loop.run_until_complete(self.start_server())\n\n            websocket_url = \"ws://localhost:{}/ws\".format(self.port)\n\n            log.debug(\n                \"Running Websocket server on URL: \\\"{}\\\"\".format(websocket_url)\n            )\n\n            asyncio.ensure_future(self.check_shutdown(), loop=self.loop)\n            self.loop.run_forever()\n        except Exception:\n            self.is_running = False\n            log.warning(\n                \"Websocket Server service has failed\", exc_info=True\n            )\n            raise\n        finally:\n            self.loop.close()  # optional\n\n            self.is_running = False\n            self.module.thread_stopped()\n            log.info(\"Websocket server stopped\")\n\n    async def start_server(self):\n        \"\"\" Starts runner and TCPsite \"\"\"\n        self.runner = web.AppRunner(self.module.app)\n        await self.runner.setup()\n        self.site = web.TCPSite(self.runner, 'localhost', self.port)\n        await self.site.start()\n\n    def stop(self):\n        \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n        self.is_running = False\n\n    async def check_shutdown(self):\n        \"\"\" Future that is running and checks if server should be running\n            periodically.\n        \"\"\"\n        while self.is_running:\n            while self.tasks:\n                task = self.tasks.pop(0)\n                log.debug(\"waiting for task {}\".format(task))\n                await task\n                log.debug(\"returned value {}\".format(task.result))\n\n            await asyncio.sleep(0.5)\n\n        log.debug(\"Starting shutdown\")\n        await self.site.stop()\n        log.debug(\"Site stopped\")\n        await self.runner.cleanup()\n        log.debug(\"Runner stopped\")\n        tasks = [task for task in asyncio.all_tasks() if\n                 task is not asyncio.current_task()]\n        list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        log.debug(f'Finished awaiting cancelled tasks, results: {results}...')\n        await self.loop.shutdown_asyncgens()\n        # to really make sure everything else has time to stop\n        await asyncio.sleep(0.07)\n        self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html#client.ayon_aftereffects.api.webserver.WebServerThread.check_shutdown","title":"<code>check_shutdown()</code>  <code>async</code>","text":"<p>Future that is running and checks if server should be running periodically.</p> Source code in <code>client/ayon_aftereffects/api/webserver.py</code> <pre><code>async def check_shutdown(self):\n    \"\"\" Future that is running and checks if server should be running\n        periodically.\n    \"\"\"\n    while self.is_running:\n        while self.tasks:\n            task = self.tasks.pop(0)\n            log.debug(\"waiting for task {}\".format(task))\n            await task\n            log.debug(\"returned value {}\".format(task.result))\n\n        await asyncio.sleep(0.5)\n\n    log.debug(\"Starting shutdown\")\n    await self.site.stop()\n    log.debug(\"Site stopped\")\n    await self.runner.cleanup()\n    log.debug(\"Runner stopped\")\n    tasks = [task for task in asyncio.all_tasks() if\n             task is not asyncio.current_task()]\n    list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    log.debug(f'Finished awaiting cancelled tasks, results: {results}...')\n    await self.loop.shutdown_asyncgens()\n    # to really make sure everything else has time to stop\n    await asyncio.sleep(0.07)\n    self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html#client.ayon_aftereffects.api.webserver.WebServerThread.start_server","title":"<code>start_server()</code>  <code>async</code>","text":"<p>Starts runner and TCPsite</p> Source code in <code>client/ayon_aftereffects/api/webserver.py</code> <pre><code>async def start_server(self):\n    \"\"\" Starts runner and TCPsite \"\"\"\n    self.runner = web.AppRunner(self.module.app)\n    await self.runner.setup()\n    self.site = web.TCPSite(self.runner, 'localhost', self.port)\n    await self.site.start()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html#client.ayon_aftereffects.api.webserver.WebServerThread.stop","title":"<code>stop()</code>","text":"<p>Sets is_running flag to false, 'check_shutdown' shuts server down</p> Source code in <code>client/ayon_aftereffects/api/webserver.py</code> <pre><code>def stop(self):\n    \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n    self.is_running = False\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html#client.ayon_aftereffects.api.webserver.WebServerTool","title":"<code>WebServerTool</code>","text":"<p>Basic POC implementation of asychronic websocket RPC server. Uses class in external_app_1.py to mimic implementation for single external application. 'test_client' folder contains two test implementations of client</p> Source code in <code>client/ayon_aftereffects/api/webserver.py</code> <pre><code>class WebServerTool:\n    \"\"\"\n        Basic POC implementation of asychronic websocket RPC server.\n        Uses class in external_app_1.py to mimic implementation for single\n        external application.\n        'test_client' folder contains two test implementations of client\n    \"\"\"\n    _instance = None\n\n    def __init__(self):\n        WebServerTool._instance = self\n\n        self.client = None\n        self.handlers = {}\n        self.on_stop_callbacks = []\n\n        port = None\n        host_name = \"localhost\"\n        websocket_url = os.getenv(\"WEBSOCKET_URL\")\n        if websocket_url:\n            parsed = urllib.parse.urlparse(websocket_url)\n            port = parsed.port\n            host_name = parsed.netloc.split(\":\")[0]\n        if not port:\n            port = 8098  # fallback\n\n        self.port = port\n        self.host_name = host_name\n\n        self.app = web.Application()\n\n        # add route with multiple methods for single \"external app\"\n        self.webserver_thread = WebServerThread(self, self.port)\n\n    def add_route(self, *args, **kwargs):\n        self.app.router.add_route(*args, **kwargs)\n\n    def add_static(self, *args, **kwargs):\n        self.app.router.add_static(*args, **kwargs)\n\n    def start_server(self):\n        if self.webserver_thread and not self.webserver_thread.is_alive():\n            self.webserver_thread.start()\n\n    def stop_server(self):\n        self.stop()\n\n    async def send_context_change(self, host):\n        \"\"\"\n            Calls running webserver to inform about context change\n\n            Used when new PS/AE should be triggered,\n            but one already running, without\n            this publish would point to old context.\n        \"\"\"\n        client = WSRPCClient(os.getenv(\"WEBSOCKET_URL\"),\n                             loop=asyncio.get_event_loop())\n        await client.connect()\n\n        context = get_global_context()\n        project_name = context[\"project_name\"]\n        folder_path = context[\"folder_path\"]\n        task_name = context[\"task_name\"]\n        log.info(\"Sending context change to {}{}/{}\".format(\n            project_name, folder_path, task_name\n        ))\n\n        await client.call(\n            '{}.set_context'.format(host),\n            project=project_name,\n            folder=folder_path,\n            task=task_name\n        )\n        await client.close()\n\n    def port_occupied(self, host_name, port):\n        \"\"\"\n            Check if 'url' is already occupied.\n\n            This could mean, that app is already running and we are trying open it\n            again. In that case, use existing running webserver.\n            Check here is easier than capturing exception from thread.\n        \"\"\"\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as con:\n            result = con.connect_ex((host_name, port)) == 0\n\n        if result:\n            print(f\"Port {port} is already in use\")\n        return result\n\n    def call(self, func):\n        log.debug(\"websocket.call {}\".format(func))\n        future = asyncio.run_coroutine_threadsafe(\n            func,\n            self.webserver_thread.loop\n        )\n        result = future.result()\n        return result\n\n    @staticmethod\n    def get_instance():\n        if WebServerTool._instance is None:\n            WebServerTool()\n        return WebServerTool._instance\n\n    @property\n    def is_running(self):\n        if not self.webserver_thread:\n            return False\n        return self.webserver_thread.is_running\n\n    def stop(self):\n        if not self.is_running:\n            return\n        try:\n            log.debug(\"Stopping websocket server\")\n            self.webserver_thread.is_running = False\n            self.webserver_thread.stop()\n        except Exception:\n            log.warning(\n                \"Error has happened during Killing websocket server\",\n                exc_info=True\n            )\n\n    def thread_stopped(self):\n        for callback in self.on_stop_callbacks:\n            callback()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html#client.ayon_aftereffects.api.webserver.WebServerTool.port_occupied","title":"<code>port_occupied(host_name, port)</code>","text":"<p>Check if 'url' is already occupied.</p> <p>This could mean, that app is already running and we are trying open it again. In that case, use existing running webserver. Check here is easier than capturing exception from thread.</p> Source code in <code>client/ayon_aftereffects/api/webserver.py</code> <pre><code>def port_occupied(self, host_name, port):\n    \"\"\"\n        Check if 'url' is already occupied.\n\n        This could mean, that app is already running and we are trying open it\n        again. In that case, use existing running webserver.\n        Check here is easier than capturing exception from thread.\n    \"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as con:\n        result = con.connect_ex((host_name, port)) == 0\n\n    if result:\n        print(f\"Port {port} is already in use\")\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/webserver.html#client.ayon_aftereffects.api.webserver.WebServerTool.send_context_change","title":"<code>send_context_change(host)</code>  <code>async</code>","text":"<p>Calls running webserver to inform about context change</p> <p>Used when new PS/AE should be triggered, but one already running, without this publish would point to old context.</p> Source code in <code>client/ayon_aftereffects/api/webserver.py</code> <pre><code>async def send_context_change(self, host):\n    \"\"\"\n        Calls running webserver to inform about context change\n\n        Used when new PS/AE should be triggered,\n        but one already running, without\n        this publish would point to old context.\n    \"\"\"\n    client = WSRPCClient(os.getenv(\"WEBSOCKET_URL\"),\n                         loop=asyncio.get_event_loop())\n    await client.connect()\n\n    context = get_global_context()\n    project_name = context[\"project_name\"]\n    folder_path = context[\"folder_path\"]\n    task_name = context[\"task_name\"]\n    log.info(\"Sending context change to {}{}/{}\".format(\n        project_name, folder_path, task_name\n    ))\n\n    await client.call(\n        '{}.set_context'.format(host),\n        project=project_name,\n        folder=folder_path,\n        task=task_name\n    )\n    await client.close()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html","title":"workfile_template_builder","text":""},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html#client.ayon_aftereffects.api.workfile_template_builder.AEPlaceholderPlugin","title":"<code>AEPlaceholderPlugin</code>","text":"<p>               Bases: <code>PlaceholderPlugin</code></p> <p>Contains generic methods for all PlaceholderPlugins.</p> Source code in <code>client/ayon_aftereffects/api/workfile_template_builder.py</code> <pre><code>class AEPlaceholderPlugin(PlaceholderPlugin):\n    \"\"\"Contains generic methods for all PlaceholderPlugins.\"\"\"\n\n    @abstractmethod\n    def _create_placeholder_item(self, item_data: dict) -&gt; PlaceholderItem:\n        pass\n\n    def collect_placeholders(self):\n        \"\"\"Collect info from file metadata about created placeholders.\n\n        Returns:\n            (list) (LoadPlaceholderItem)\n        \"\"\"\n        output = []\n        scene_placeholders = self._collect_scene_placeholders()\n        for item in scene_placeholders:\n            if item.get(\"plugin_identifier\") != self.identifier:\n                continue\n\n            item = self._create_placeholder_item(item)\n            output.append(item)\n\n        return output\n\n    def update_placeholder(self, placeholder_item, placeholder_data):\n        \"\"\"Resave changed properties for placeholders\"\"\"\n        item_id, metadata_item = self._get_item(placeholder_item)\n        stub = get_stub()\n        if not item_id:\n            stub.print_msg(\"Cannot find item for \"\n                           f\"{placeholder_item.scene_identifier}\")\n            return\n        metadata_item[\"data\"] = placeholder_data\n        stub.imprint(item_id, metadata_item)\n\n    def _get_item(self, placeholder_item):\n        \"\"\"Returns item id and item metadata for placeholder from file meta\"\"\"\n        stub = get_stub()\n        placeholder_uuid = placeholder_item.scene_identifier\n        for metadata_item in stub.get_metadata():\n            if not metadata_item.get(\"is_placeholder\"):\n                continue\n            if placeholder_uuid in metadata_item.get(\"uuid\"):\n                return metadata_item[\"members\"][0], metadata_item\n        return None, None\n\n    def _collect_scene_placeholders(self):\n        \"\"\"Cache placeholder data to shared data.\n        Returns:\n            (list) of dicts\n        \"\"\"\n        placeholder_items = self.builder.get_shared_populate_data(\n            \"placeholder_items\"\n        )\n        if not placeholder_items:\n            placeholder_items = []\n            for item in get_stub().get_metadata():\n                if not item.get(\"is_placeholder\"):\n                    continue\n                placeholder_items.append(item)\n\n            self.builder.set_shared_populate_data(\n                \"placeholder_items\", placeholder_items\n            )\n        return placeholder_items\n\n    def _imprint_item(self, item_id, name, placeholder_data, stub):\n        if not item_id:\n            raise ValueError(\"Couldn't create a placeholder\")\n        container_data = {\n            \"id\": PLACEHOLDER_ID,\n            \"name\": name,\n            \"is_placeholder\": True,\n            \"plugin_identifier\": self.identifier,\n            \"uuid\": str(uuid.uuid4()),  # scene_identifier\n            \"data\": placeholder_data,\n            \"members\": [item_id]\n        }\n        stub.imprint(item_id, container_data)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html#client.ayon_aftereffects.api.workfile_template_builder.AEPlaceholderPlugin.collect_placeholders","title":"<code>collect_placeholders()</code>","text":"<p>Collect info from file metadata about created placeholders.</p> <p>Returns:</p> Type Description <p>(list) (LoadPlaceholderItem)</p> Source code in <code>client/ayon_aftereffects/api/workfile_template_builder.py</code> <pre><code>def collect_placeholders(self):\n    \"\"\"Collect info from file metadata about created placeholders.\n\n    Returns:\n        (list) (LoadPlaceholderItem)\n    \"\"\"\n    output = []\n    scene_placeholders = self._collect_scene_placeholders()\n    for item in scene_placeholders:\n        if item.get(\"plugin_identifier\") != self.identifier:\n            continue\n\n        item = self._create_placeholder_item(item)\n        output.append(item)\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html#client.ayon_aftereffects.api.workfile_template_builder.AEPlaceholderPlugin.update_placeholder","title":"<code>update_placeholder(placeholder_item, placeholder_data)</code>","text":"<p>Resave changed properties for placeholders</p> Source code in <code>client/ayon_aftereffects/api/workfile_template_builder.py</code> <pre><code>def update_placeholder(self, placeholder_item, placeholder_data):\n    \"\"\"Resave changed properties for placeholders\"\"\"\n    item_id, metadata_item = self._get_item(placeholder_item)\n    stub = get_stub()\n    if not item_id:\n        stub.print_msg(\"Cannot find item for \"\n                       f\"{placeholder_item.scene_identifier}\")\n        return\n    metadata_item[\"data\"] = placeholder_data\n    stub.imprint(item_id, metadata_item)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html#client.ayon_aftereffects.api.workfile_template_builder.AETemplateBuilder","title":"<code>AETemplateBuilder</code>","text":"<p>               Bases: <code>AbstractTemplateBuilder</code></p> <p>Concrete implementation of AbstractTemplateBuilder for AE</p> Source code in <code>client/ayon_aftereffects/api/workfile_template_builder.py</code> <pre><code>class AETemplateBuilder(AbstractTemplateBuilder):\n    \"\"\"Concrete implementation of AbstractTemplateBuilder for AE\"\"\"\n\n    def import_template(self, path):\n        \"\"\"Import template into current scene.\n        Block if a template is already loaded.\n\n        Args:\n            path (str): A path to current template (usually given by\n            get_template_preset implementation)\n\n        Returns:\n            bool: Whether the template was successfully imported or not\n        \"\"\"\n        stub = get_stub()\n        if not os.path.exists(path):\n            stub.print_msg(f\"Template file on {path} doesn't exist.\")\n            return\n\n        stub.save()\n        workfile_path = stub.get_active_document_full_name()\n        shutil.copy2(path, workfile_path)\n        stub.open(workfile_path)\n\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html#client.ayon_aftereffects.api.workfile_template_builder.AETemplateBuilder.import_template","title":"<code>import_template(path)</code>","text":"<p>Import template into current scene. Block if a template is already loaded.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>A path to current template (usually given by</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether the template was successfully imported or not</p> Source code in <code>client/ayon_aftereffects/api/workfile_template_builder.py</code> <pre><code>def import_template(self, path):\n    \"\"\"Import template into current scene.\n    Block if a template is already loaded.\n\n    Args:\n        path (str): A path to current template (usually given by\n        get_template_preset implementation)\n\n    Returns:\n        bool: Whether the template was successfully imported or not\n    \"\"\"\n    stub = get_stub()\n    if not os.path.exists(path):\n        stub.print_msg(f\"Template file on {path} doesn't exist.\")\n        return\n\n    stub.save()\n    workfile_path = stub.get_active_document_full_name()\n    shutil.copy2(path, workfile_path)\n    stub.open(workfile_path)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html#client.ayon_aftereffects.api.workfile_template_builder.create_placeholder","title":"<code>create_placeholder(*args)</code>","text":"<p>Called when new workile placeholder should be created.</p> Source code in <code>client/ayon_aftereffects/api/workfile_template_builder.py</code> <pre><code>def create_placeholder(*args):\n    \"\"\"Called when new workile placeholder should be created.\"\"\"\n    host = registered_host()\n    builder = AETemplateBuilder(host)\n    window = WorkfileBuildPlaceholderDialog(host, builder)\n    window.exec_()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/workfile_template_builder.html#client.ayon_aftereffects.api.workfile_template_builder.update_placeholder","title":"<code>update_placeholder(*args)</code>","text":"<p>Called after placeholder item is selected to modify it.</p> Source code in <code>client/ayon_aftereffects/api/workfile_template_builder.py</code> <pre><code>def update_placeholder(*args):\n    \"\"\"Called after placeholder item is selected to modify it.\"\"\"\n    host = registered_host()\n    builder = AETemplateBuilder(host)\n\n    stub = get_stub()\n    selected_items = stub.get_selected_items(True, True, True)\n\n    if len(selected_items) != 1:\n        stub.print_msg(\"Please select just 1 placeholder\")\n        return\n\n    selected_id = selected_items[0].id\n    placeholder_item = None\n\n    placeholder_items_by_id = {\n        placeholder_item.scene_identifier: placeholder_item\n        for placeholder_item in builder.get_placeholders()\n    }\n    for metadata_item in stub.get_metadata():\n        if not metadata_item.get(\"is_placeholder\"):\n            continue\n        if selected_id in metadata_item.get(\"members\"):\n            placeholder_item = placeholder_items_by_id.get(\n                metadata_item[\"uuid\"])\n            break\n\n    if not placeholder_item:\n        stub.print_msg(\"Didn't find placeholder metadata. \"\n                       \"Remove and re-create placeholder.\")\n        return\n\n    window = WorkfileBuildPlaceholderDialog(host, builder)\n    window.set_update_mode(placeholder_item)\n    window.exec_()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html","title":"ws_stub","text":"<p>Stub handling connection from server to client. Used anywhere solution is calling client methods.</p>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AEItem","title":"<code>AEItem</code>","text":"<p>               Bases: <code>object</code></p> <p>Object denoting Item in AE. Each item is created in AE by any Loader, but contains same fields, which are being used in later processing.</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>@attr.s\nclass AEItem(object):\n    \"\"\"\n        Object denoting Item in AE. Each item is created in AE by any Loader,\n        but contains same fields, which are being used in later processing.\n    \"\"\"\n    # metadata\n    id = attr.ib()  # id created by AE, could be used for querying\n    name = attr.ib()  # name of item\n    item_type = attr.ib(default=None)  # item type (footage, folder, comp)\n    # all imported elements, single for\n    # regular image, array for Backgrounds\n    members = attr.ib(factory=list)\n    frameStart = attr.ib(default=None)\n    framesDuration = attr.ib(default=None)\n    frameRate = attr.ib(default=None)\n    file_name = attr.ib(default=None)\n    instance_id = attr.ib(default=None)  # New Publisher\n    width = attr.ib(default=None)\n    height = attr.ib(default=None)\n    is_placeholder = attr.ib(default=False)\n    uuid = attr.ib(default=False)\n    path = attr.ib(default=False)  # path to FootageItem to validate\n    # list of composition Footage is in\n    containing_comps = attr.ib(factory=list)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub","title":"<code>AfterEffectsServerStub</code>","text":"<p>Stub for calling function on client (After Effects js) side.</p> <p>Expects that client is already connected (started when AYON menu is opened)</p> <p>'self.websocketserver.call' is used as async wrapper</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>class AfterEffectsServerStub():\n    \"\"\"Stub for calling function on client (After Effects js) side.\n\n    Expects that client is already connected (started when AYON menu is opened)\n\n    'self.websocketserver.call' is used as async wrapper\n    \"\"\"\n    PUBLISH_ICON = '\\u2117 '\n    LOADED_ICON = '\\u25bc'\n\n    def __init__(self):\n        self.websocketserver = WebServerTool.get_instance()\n        self.client = self.get_client()\n        self.log = logging.getLogger(self.__class__.__name__)\n\n    @staticmethod\n    def get_client():\n        \"\"\"\n            Return first connected client to WebSocket\n            TODO implement selection by Route\n        :return: &lt;WebSocketAsync&gt; client\n        \"\"\"\n        clients = WebSocketAsync.get_clients()\n        client = None\n        if len(clients) &gt; 0:\n            key = list(clients.keys())[0]\n            client = clients.get(key)\n\n        return client\n\n    def open(self, path):\n        \"\"\"\n            Open file located at 'path' (local).\n        Args:\n            path(string): file path locally\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.open', path=path))\n\n        return self._handle_return(res)\n\n    def get_metadata(self):\n        \"\"\"\n            Get complete stored JSON with metadata from AE.Metadata.Label\n            field.\n\n            It contains containers loaded by any Loader OR instances created\n            by Creator.\n\n        Returns:\n            (list)\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.get_metadata'))\n        metadata = self._handle_return(res)\n\n        return metadata or []\n\n    def read(self, item, layers_meta=None):\n        \"\"\"\n            Parses item metadata from Label field of active document.\n            Used as filter to pick metadata for specific 'item' only.\n\n        Args:\n            item (AEItem): pulled info from AE\n            layers_meta (dict): full list from Headline\n                (load and inject for better performance in loops)\n        Returns:\n            (dict):\n        \"\"\"\n        if layers_meta is None:\n            layers_meta = self.get_metadata()\n        for item_meta in layers_meta:\n            if 'container' in item_meta.get('id') and \\\n                    str(item.id) == str(item_meta.get('members')[0]):\n                return item_meta\n\n        self.log.debug(f\"Couldn't find layer metadata for item: {item}\")\n\n    def imprint(self, item_id, data, all_items=None, items_meta=None):\n        \"\"\"\n            Save item metadata to Label field of metadata of active document\n        Args:\n            item_id (int|str): id of FootageItem or instance_id for workfiles\n            data(string): json representation for single layer\n            all_items (list of item): for performance, could be\n                injected for usage in loop, if not, single call will be\n                triggered\n            items_meta(string): json representation from Headline\n                           (for performance - provide only if imprint is in\n                           loop - value should be same)\n        Returns: None\n        \"\"\"\n        if not items_meta:\n            items_meta = self.get_metadata()\n\n        result_meta = []\n        # fix existing\n        is_new = True\n\n        for item_meta in items_meta:\n            if ((item_meta.get('members') and\n                    str(item_id) == str(item_meta.get('members')[0])) or\n                    item_meta.get(\"instance_id\") == item_id):\n                is_new = False\n                if data:\n                    item_meta.update(data)\n                    result_meta.append(item_meta)\n            else:\n                result_meta.append(item_meta)\n\n        if is_new:\n            result_meta.append(data)\n\n        # Ensure only valid ids are stored.\n        if not all_items:\n            # loaders create FootageItem now\n            all_items = self.get_items(comps=True,\n                                       folders=True,\n                                       footages=True)\n        item_ids = [int(item.id) for item in all_items]\n        cleaned_data = []\n        for meta in result_meta:\n            # do not added instance with nonexistend item id\n            if meta.get(\"members\"):\n                if int(meta[\"members\"][0]) not in item_ids:\n                    continue\n\n            cleaned_data.append(meta)\n\n        payload = json.dumps(cleaned_data, indent=4)\n\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.imprint',\n                                         payload=payload))\n        return self._handle_return(res)\n\n    def get_active_document_full_name(self):\n        \"\"\"\n            Returns absolute path of active document via ws call\n        Returns(string): file name\n        \"\"\"\n        res = self.websocketserver.call(self.client.call(\n            'AfterEffects.get_active_document_full_name'))\n\n        return self._handle_return(res)\n\n    def get_active_document_name(self):\n        \"\"\"\n            Returns just a name of active document via ws call\n        Returns(string): file name\n        \"\"\"\n        res = self.websocketserver.call(self.client.call(\n            'AfterEffects.get_active_document_name'))\n\n        return self._handle_return(res)\n\n    def get_items(self, comps, folders=False, footages=False):\n        \"\"\"\n            Get all items from Project panel according to arguments.\n            There are multiple different types:\n                CompItem (could have multiple layers - source for Creator,\n                    will be rendered)\n                FolderItem (collection type, currently used for Background\n                    loading)\n                FootageItem (imported file - created by Loader)\n        Args:\n            comps (bool): return CompItems\n            folders (bool): return FolderItem\n            footages (bool: return FootageItem\n\n        Returns:\n            (list) of namedtuples\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call('AfterEffects.get_items',\n                             comps=comps,\n                             folders=folders,\n                             footages=footages)\n              )\n        return self._to_records(self._handle_return(res))\n\n    def select_items(self, items):\n        \"\"\"\n            Select items in Project list\n        Args:\n            items (list): of int item ids\n        \"\"\"\n        self.websocketserver.call(\n            self.client.call('AfterEffects.select_items', items=items))\n\n\n    def get_selected_items(self, comps, folders=False, footages=False):\n        \"\"\"\n            Same as get_items but using selected items only\n        Args:\n            comps (bool): return CompItems\n            folders (bool): return FolderItem\n            footages (bool: return FootageItem\n\n        Returns:\n            (list) of namedtuples\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.get_selected_items',\n                                         comps=comps,\n                                         folders=folders,\n                                         footages=footages)\n                                        )\n        return self._to_records(self._handle_return(res))\n\n    def add_item(self, name, item_type):\n        \"\"\"\n            Adds either composition or folder to project item list.\n\n            Args:\n                name (str)\n                item_type (str): COMP|FOLDER\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.add_item',\n                                         name=name,\n                                         item_type=item_type))\n\n        return self._handle_return(res)\n\n    def get_item(self, item_id):\n        \"\"\"\n            Returns metadata for particular 'item_id' or None\n\n            Args:\n                item_id (int, or string)\n        \"\"\"\n        for item in self.get_items(True, True, True):\n            if str(item.id) == str(item_id):\n                return item\n\n        return None\n\n    def import_file(self, path, item_name, import_options=None):\n        \"\"\"\n            Imports file as a FootageItem. Used in Loader\n        Args:\n            path (string): absolute path for asset file\n            item_name (string): label for created FootageItem\n            import_options (dict): different files (img vs psd) need different\n                config\n\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call('AfterEffects.import_file',\n                             path=path,\n                             item_name=item_name,\n                             import_options=import_options)\n            )\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def replace_item(self, item_id, path, item_name):\n        \"\"\" Replace FootageItem with new file\n\n            Args:\n                item_id (int):\n                path (string):absolute path\n                item_name (string): label on item in Project list\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.replace_item',\n                                         item_id=item_id,\n                                         path=path, item_name=item_name))\n\n        return self._handle_return(res)\n\n    def rename_item(self, item_id, item_name):\n        \"\"\" Replace item with item_name\n\n            Args:\n                item_id (int):\n                item_name (string): label on item in Project list\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.rename_item',\n                                         item_id=item_id,\n                                         item_name=item_name))\n\n        return self._handle_return(res)\n\n    def delete_item(self, item_id):\n        \"\"\" Deletes *Item in a file\n            Args:\n                item_id (int):\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.delete_item',\n                                         item_id=item_id))\n\n        return self._handle_return(res)\n\n    def remove_instance(self, instance_id, metadata=None):\n        \"\"\"\n            Removes instance with 'instance_id' from file's metadata and\n            saves them.\n\n            Keep matching item in file though.\n\n            Args:\n                instance_id(string): instance id\n        \"\"\"\n        cleaned_data = []\n\n        if metadata is None:\n            metadata = self.get_metadata()\n\n        for instance in metadata:\n            inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")\n            if inst_id != instance_id:\n                cleaned_data.append(instance)\n\n        payload = json.dumps(cleaned_data, indent=4)\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.imprint',\n                                         payload=payload))\n\n        return self._handle_return(res)\n\n    def is_saved(self):\n        # TODO\n        return True\n\n    def set_label_color(self, item_id, color_idx):\n        \"\"\"\n            Used for highlight additional information in Project panel.\n            Green color is loaded asset, blue is created asset\n        Args:\n            item_id (int):\n            color_idx (int): 0-16 Label colors from AE Project view\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.set_label_color',\n                                         item_id=item_id,\n                                         color_idx=color_idx))\n\n        return self._handle_return(res)\n\n    def get_comp_properties(self, comp_id):\n        \"\"\" Get composition information for render purposes\n\n            Returns startFrame, frameDuration, fps, width, height.\n\n            Args:\n                comp_id (int):\n\n            Returns:\n                (AEItem)\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.get_comp_properties',\n                                         item_id=comp_id\n                                         ))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def set_comp_properties(self, comp_id, start, duration, frame_rate,\n                            width, height):\n        \"\"\"\n            Set work area to predefined values (from Ftrack).\n            Work area directs what gets rendered.\n            Beware of rounding, AE expects seconds, not frames directly.\n\n        Args:\n            comp_id (int):\n            start (int): workAreaStart in frames\n            duration (int): in frames\n            frame_rate (float): frames in seconds\n            width (int): resolution width\n            height (int): resolution height\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.set_comp_properties',\n                                         item_id=comp_id,\n                                         start=start,\n                                         duration=duration,\n                                         frame_rate=frame_rate,\n                                         width=width,\n                                         height=height))\n        return self._handle_return(res)\n\n    def save(self):\n        \"\"\"\n            Saves active document\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.save'))\n\n        return self._handle_return(res)\n\n    def saveAs(self, project_path, as_copy):\n        \"\"\"\n            Saves active project to aep (copy) or png or jpg\n        Args:\n            project_path(string): full local path\n            as_copy: &lt;boolean&gt;\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.saveAs',\n                                         image_path=project_path,\n                                         as_copy=as_copy))\n\n        return self._handle_return(res)\n\n    def get_render_info(self, comp_id):\n        \"\"\" Get render queue info for render purposes\n\n            Returns:\n               (list) of (AEItem): with 'file_name' field\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.get_render_info',\n                                         comp_id=comp_id))\n\n        records = self._to_records(self._handle_return(res))\n        return records\n\n    def get_audio_url(self, item_id):\n        \"\"\" Get audio layer absolute url for comp\n\n            Args:\n                item_id (int): composition id\n            Returns:\n                (str): absolute path url\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.get_audio_url',\n                                         item_id=item_id))\n\n        return self._handle_return(res)\n\n    def import_background(self, comp_id, comp_name, files):\n        \"\"\"\n            Imports backgrounds images to existing or new composition.\n\n            If comp_id is not provided, new composition is created, basic\n            values (width, heights, frameRatio) takes from first imported\n            image.\n\n            All images from background json are imported as a FootageItem and\n            separate layer is created for each of them under composition.\n\n            Order of imported 'files' is important.\n\n            Args:\n                comp_id (int): id of existing composition (null if new)\n                comp_name (str): used when new composition\n                files (list): list of absolute paths to import and\n                add as layers\n\n            Returns:\n                (AEItem): object with id of created folder, all imported images\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.import_background',\n                                         comp_id=comp_id,\n                                         comp_name=comp_name,\n                                         files=files))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def reload_background(self, comp_id, comp_name, files):\n        \"\"\"\n            Reloads backgrounds images to existing composition.\n\n            It actually deletes complete folder with imported images and\n            created composition for safety.\n\n            Args:\n                comp_id (int): id of existing composition to be overwritten\n                comp_name (str): new name of composition (could be same as old\n                    if version up only)\n                files (list): list of absolute paths to import and\n                    add as layers\n            Returns:\n                (AEItem): object with id of created folder, all imported images\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.reload_background',\n                                         comp_id=comp_id,\n                                         comp_name=comp_name,\n                                         files=files))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def add_item_as_layer(self, comp_id, item_id):\n        \"\"\"\n            Adds already imported FootageItem ('item_id') as a new\n            layer to composition ('comp_id').\n\n            Args:\n                comp_id (int): id of target composition\n                item_id (int): FootageItem.id\n                comp already found previously\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.add_item_as_layer',\n                                         comp_id=comp_id,\n                                         item_id=item_id))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def add_item_instead_placeholder(self, placeholder_item_id, item_id):\n        \"\"\"\n            Adds item_id to layers where plaeholder_item_id is present.\n\n            1 placeholder could result in multiple loaded containers (eg items)\n\n            Args:\n                placeholder_item_id (int): id of placeholder item\n                item_id (int): loaded FootageItem id\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.add_item_instead_placeholder',  # noqa\n                                         placeholder_item_id=placeholder_item_id,  # noqa\n                                         item_id=item_id))\n\n        return self._handle_return(res)\n\n    def add_placeholder(self, name, width, height, fps, duration):\n        \"\"\"\n            Adds new FootageItem as a placeholder for workfile builder\n\n            Placeholder requires width etc, currently probably only hardcoded\n            values.\n\n            Args:\n                name (str)\n                width (int)\n                height (int)\n                fps (float)\n                duration (int)\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.add_placeholder',\n                                         name=name,\n                                         width=width,\n                                         height=height,\n                                         fps=fps,\n                                         duration=duration))\n\n        return self._handle_return(res)\n\n    def render(self, folder_url, comp_id):\n        \"\"\"\n            Render all renderqueueitem to 'folder_url'\n        Args:\n            folder_url(string): local folder path for collecting\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        ('AfterEffects.render',\n                                         folder_url=folder_url,\n                                         comp_id=comp_id))\n        return self._handle_return(res)\n\n    def get_extension_version(self):\n        \"\"\"Returns version number of installed extension.\"\"\"\n        res = self.websocketserver.call(self.client.call(\n            'AfterEffects.get_extension_version'))\n\n        return self._handle_return(res)\n\n    def get_app_version(self):\n        \"\"\"Returns version number of installed application (17.5...).\"\"\"\n        res = self.websocketserver.call(self.client.call(\n            'AfterEffects.get_app_version'))\n\n        return self._handle_return(res)\n\n    def close(self):\n        res = self.websocketserver.call(self.client.call('AfterEffects.close'))\n\n        return self._handle_return(res)\n\n    def print_msg(self, msg):\n        \"\"\"Triggers Javascript alert dialog.\"\"\"\n        self.websocketserver.call(self.client.call\n                                  ('AfterEffects.print_msg',\n                                   msg=msg))\n\n    def _handle_return(self, res):\n        \"\"\"Wraps return, throws ValueError if 'error' key is present.\"\"\"\n        if res and isinstance(res, str) and res != \"undefined\":\n            try:\n                parsed = json.loads(res)\n            except json.decoder.JSONDecodeError:\n                raise ValueError(\"Received broken JSON {}\".format(res))\n\n            if not parsed:  # empty list\n                return parsed\n\n            first_item = parsed\n            if isinstance(parsed, list):\n                first_item = parsed[0]\n\n            if first_item:\n                if first_item.get(\"error\"):\n                    raise ValueError(first_item[\"error\"])\n                # singular values (file name etc)\n                if first_item.get(\"result\") is not None:\n                    return first_item[\"result\"]\n            return parsed  # parsed\n        return res\n\n    def _to_records(self, payload):\n        \"\"\"\n            Converts string json representation into list of AEItem\n            dot notation access to work.\n        Returns: &lt;list of AEItem&gt;\n            payload(dict): - dictionary from json representation, expected to\n                come from _handle_return\n        \"\"\"\n        if not payload:\n            return []\n\n        if isinstance(payload, str):  # safety fallback\n            try:\n                payload = json.loads(payload)\n            except json.decoder.JSONDecodeError:\n                raise ValueError(\"Received broken JSON {}\".format(payload))\n\n        if isinstance(payload, dict):\n            payload = [payload]\n\n        ret = []\n        # convert to AEItem to use dot donation\n        for d in payload:\n            if not d:\n                continue\n            # currently implemented and expected fields\n            item = AEItem(d.get('id'),\n                          d.get('name'),\n                          d.get('type'),\n                          d.get('members'),\n                          d.get('frameStart'),\n                          d.get('framesDuration'),\n                          d.get('frameRate'),\n                          d.get('file_name'),\n                          d.get(\"instance_id\"),\n                          d.get(\"width\"),\n                          d.get(\"height\"),\n                          d.get(\"is_placeholder\"),\n                          d.get(\"uuid\"),\n                          d.get(\"path\"),\n                          d.get(\"containing_comps\"),)\n\n            ret.append(item)\n        return ret\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.add_item","title":"<code>add_item(name, item_type)</code>","text":"<p>Adds either composition or folder to project item list.</p> <p>Parameters:</p> Name Type Description Default <code>item_type</code> <code>str</code> <p>COMP|FOLDER</p> required Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def add_item(self, name, item_type):\n    \"\"\"\n        Adds either composition or folder to project item list.\n\n        Args:\n            name (str)\n            item_type (str): COMP|FOLDER\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.add_item',\n                                     name=name,\n                                     item_type=item_type))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.add_item_as_layer","title":"<code>add_item_as_layer(comp_id, item_id)</code>","text":"<p>Adds already imported FootageItem ('item_id') as a new layer to composition ('comp_id').</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> <p>id of target composition</p> required <code>item_id</code> <code>int</code> <p>FootageItem.id</p> required Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def add_item_as_layer(self, comp_id, item_id):\n    \"\"\"\n        Adds already imported FootageItem ('item_id') as a new\n        layer to composition ('comp_id').\n\n        Args:\n            comp_id (int): id of target composition\n            item_id (int): FootageItem.id\n            comp already found previously\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.add_item_as_layer',\n                                     comp_id=comp_id,\n                                     item_id=item_id))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.add_item_instead_placeholder","title":"<code>add_item_instead_placeholder(placeholder_item_id, item_id)</code>","text":"<p>Adds item_id to layers where plaeholder_item_id is present.</p> <p>1 placeholder could result in multiple loaded containers (eg items)</p> <p>Parameters:</p> Name Type Description Default <code>placeholder_item_id</code> <code>int</code> <p>id of placeholder item</p> required <code>item_id</code> <code>int</code> <p>loaded FootageItem id</p> required Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def add_item_instead_placeholder(self, placeholder_item_id, item_id):\n    \"\"\"\n        Adds item_id to layers where plaeholder_item_id is present.\n\n        1 placeholder could result in multiple loaded containers (eg items)\n\n        Args:\n            placeholder_item_id (int): id of placeholder item\n            item_id (int): loaded FootageItem id\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.add_item_instead_placeholder',  # noqa\n                                     placeholder_item_id=placeholder_item_id,  # noqa\n                                     item_id=item_id))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.add_placeholder","title":"<code>add_placeholder(name, width, height, fps, duration)</code>","text":"<p>Adds new FootageItem as a placeholder for workfile builder</p> <p>Placeholder requires width etc, currently probably only hardcoded values.</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def add_placeholder(self, name, width, height, fps, duration):\n    \"\"\"\n        Adds new FootageItem as a placeholder for workfile builder\n\n        Placeholder requires width etc, currently probably only hardcoded\n        values.\n\n        Args:\n            name (str)\n            width (int)\n            height (int)\n            fps (float)\n            duration (int)\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.add_placeholder',\n                                     name=name,\n                                     width=width,\n                                     height=height,\n                                     fps=fps,\n                                     duration=duration))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.delete_item","title":"<code>delete_item(item_id)</code>","text":"<p>Deletes *Item in a file Args:     item_id (int):</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def delete_item(self, item_id):\n    \"\"\" Deletes *Item in a file\n        Args:\n            item_id (int):\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.delete_item',\n                                     item_id=item_id))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_active_document_full_name","title":"<code>get_active_document_full_name()</code>","text":"<pre><code>Returns absolute path of active document via ws call\n</code></pre> <p>Returns(string): file name</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_active_document_full_name(self):\n    \"\"\"\n        Returns absolute path of active document via ws call\n    Returns(string): file name\n    \"\"\"\n    res = self.websocketserver.call(self.client.call(\n        'AfterEffects.get_active_document_full_name'))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_active_document_name","title":"<code>get_active_document_name()</code>","text":"<pre><code>Returns just a name of active document via ws call\n</code></pre> <p>Returns(string): file name</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_active_document_name(self):\n    \"\"\"\n        Returns just a name of active document via ws call\n    Returns(string): file name\n    \"\"\"\n    res = self.websocketserver.call(self.client.call(\n        'AfterEffects.get_active_document_name'))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_app_version","title":"<code>get_app_version()</code>","text":"<p>Returns version number of installed application (17.5...).</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_app_version(self):\n    \"\"\"Returns version number of installed application (17.5...).\"\"\"\n    res = self.websocketserver.call(self.client.call(\n        'AfterEffects.get_app_version'))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_audio_url","title":"<code>get_audio_url(item_id)</code>","text":"<p>Get audio layer absolute url for comp</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>composition id</p> required <p>Returns:     (str): absolute path url</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_audio_url(self, item_id):\n    \"\"\" Get audio layer absolute url for comp\n\n        Args:\n            item_id (int): composition id\n        Returns:\n            (str): absolute path url\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.get_audio_url',\n                                     item_id=item_id))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_client","title":"<code>get_client()</code>  <code>staticmethod</code>","text":"<pre><code>Return first connected client to WebSocket\nTODO implement selection by Route\n</code></pre> <p>:return:  client Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>@staticmethod\ndef get_client():\n    \"\"\"\n        Return first connected client to WebSocket\n        TODO implement selection by Route\n    :return: &lt;WebSocketAsync&gt; client\n    \"\"\"\n    clients = WebSocketAsync.get_clients()\n    client = None\n    if len(clients) &gt; 0:\n        key = list(clients.keys())[0]\n        client = clients.get(key)\n\n    return client\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_comp_properties","title":"<code>get_comp_properties(comp_id)</code>","text":"<p>Get composition information for render purposes</p> <p>Returns startFrame, frameDuration, fps, width, height.</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> required <p>Returns:</p> Type Description <p>(AEItem)</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_comp_properties(self, comp_id):\n    \"\"\" Get composition information for render purposes\n\n        Returns startFrame, frameDuration, fps, width, height.\n\n        Args:\n            comp_id (int):\n\n        Returns:\n            (AEItem)\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.get_comp_properties',\n                                     item_id=comp_id\n                                     ))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_extension_version","title":"<code>get_extension_version()</code>","text":"<p>Returns version number of installed extension.</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_extension_version(self):\n    \"\"\"Returns version number of installed extension.\"\"\"\n    res = self.websocketserver.call(self.client.call(\n        'AfterEffects.get_extension_version'))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_item","title":"<code>get_item(item_id)</code>","text":"<p>Returns metadata for particular 'item_id' or None</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_item(self, item_id):\n    \"\"\"\n        Returns metadata for particular 'item_id' or None\n\n        Args:\n            item_id (int, or string)\n    \"\"\"\n    for item in self.get_items(True, True, True):\n        if str(item.id) == str(item_id):\n            return item\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_items","title":"<code>get_items(comps, folders=False, footages=False)</code>","text":"<pre><code>Get all items from Project panel according to arguments.\nThere are multiple different types:\n    CompItem (could have multiple layers - source for Creator,\n        will be rendered)\n    FolderItem (collection type, currently used for Background\n        loading)\n    FootageItem (imported file - created by Loader)\n</code></pre> <p>Args:     comps (bool): return CompItems     folders (bool): return FolderItem     footages (bool: return FootageItem</p> <p>Returns:</p> Type Description <p>(list) of namedtuples</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_items(self, comps, folders=False, footages=False):\n    \"\"\"\n        Get all items from Project panel according to arguments.\n        There are multiple different types:\n            CompItem (could have multiple layers - source for Creator,\n                will be rendered)\n            FolderItem (collection type, currently used for Background\n                loading)\n            FootageItem (imported file - created by Loader)\n    Args:\n        comps (bool): return CompItems\n        folders (bool): return FolderItem\n        footages (bool: return FootageItem\n\n    Returns:\n        (list) of namedtuples\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call('AfterEffects.get_items',\n                         comps=comps,\n                         folders=folders,\n                         footages=footages)\n          )\n    return self._to_records(self._handle_return(res))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_metadata","title":"<code>get_metadata()</code>","text":"<pre><code>Get complete stored JSON with metadata from AE.Metadata.Label\nfield.\n\nIt contains containers loaded by any Loader OR instances created\nby Creator.\n</code></pre> <p>Returns:</p> Type Description <p>(list)</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_metadata(self):\n    \"\"\"\n        Get complete stored JSON with metadata from AE.Metadata.Label\n        field.\n\n        It contains containers loaded by any Loader OR instances created\n        by Creator.\n\n    Returns:\n        (list)\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.get_metadata'))\n    metadata = self._handle_return(res)\n\n    return metadata or []\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_render_info","title":"<code>get_render_info(comp_id)</code>","text":"<p>Get render queue info for render purposes</p> <p>Returns:</p> Type Description <code>list) of (AEItem</code> <p>with 'file_name' field</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_render_info(self, comp_id):\n    \"\"\" Get render queue info for render purposes\n\n        Returns:\n           (list) of (AEItem): with 'file_name' field\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.get_render_info',\n                                     comp_id=comp_id))\n\n    records = self._to_records(self._handle_return(res))\n    return records\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.get_selected_items","title":"<code>get_selected_items(comps, folders=False, footages=False)</code>","text":"<pre><code>Same as get_items but using selected items only\n</code></pre> <p>Args:     comps (bool): return CompItems     folders (bool): return FolderItem     footages (bool: return FootageItem</p> <p>Returns:</p> Type Description <p>(list) of namedtuples</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_selected_items(self, comps, folders=False, footages=False):\n    \"\"\"\n        Same as get_items but using selected items only\n    Args:\n        comps (bool): return CompItems\n        folders (bool): return FolderItem\n        footages (bool: return FootageItem\n\n    Returns:\n        (list) of namedtuples\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.get_selected_items',\n                                     comps=comps,\n                                     folders=folders,\n                                     footages=footages)\n                                    )\n    return self._to_records(self._handle_return(res))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.import_background","title":"<code>import_background(comp_id, comp_name, files)</code>","text":"<p>Imports backgrounds images to existing or new composition.</p> <p>If comp_id is not provided, new composition is created, basic values (width, heights, frameRatio) takes from first imported image.</p> <p>All images from background json are imported as a FootageItem and separate layer is created for each of them under composition.</p> <p>Order of imported 'files' is important.</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> <p>id of existing composition (null if new)</p> required <code>comp_name</code> <code>str</code> <p>used when new composition</p> required <code>files</code> <code>list</code> <p>list of absolute paths to import and</p> required <p>Returns:</p> Type Description <code>AEItem</code> <p>object with id of created folder, all imported images</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def import_background(self, comp_id, comp_name, files):\n    \"\"\"\n        Imports backgrounds images to existing or new composition.\n\n        If comp_id is not provided, new composition is created, basic\n        values (width, heights, frameRatio) takes from first imported\n        image.\n\n        All images from background json are imported as a FootageItem and\n        separate layer is created for each of them under composition.\n\n        Order of imported 'files' is important.\n\n        Args:\n            comp_id (int): id of existing composition (null if new)\n            comp_name (str): used when new composition\n            files (list): list of absolute paths to import and\n            add as layers\n\n        Returns:\n            (AEItem): object with id of created folder, all imported images\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.import_background',\n                                     comp_id=comp_id,\n                                     comp_name=comp_name,\n                                     files=files))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.import_file","title":"<code>import_file(path, item_name, import_options=None)</code>","text":"<pre><code>Imports file as a FootageItem. Used in Loader\n</code></pre> <p>Args:     path (string): absolute path for asset file     item_name (string): label for created FootageItem     import_options (dict): different files (img vs psd) need different         config</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def import_file(self, path, item_name, import_options=None):\n    \"\"\"\n        Imports file as a FootageItem. Used in Loader\n    Args:\n        path (string): absolute path for asset file\n        item_name (string): label for created FootageItem\n        import_options (dict): different files (img vs psd) need different\n            config\n\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call('AfterEffects.import_file',\n                         path=path,\n                         item_name=item_name,\n                         import_options=import_options)\n        )\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.imprint","title":"<code>imprint(item_id, data, all_items=None, items_meta=None)</code>","text":"<pre><code>Save item metadata to Label field of metadata of active document\n</code></pre> <p>Args:     item_id (int|str): id of FootageItem or instance_id for workfiles     data(string): json representation for single layer     all_items (list of item): for performance, could be         injected for usage in loop, if not, single call will be         triggered     items_meta(string): json representation from Headline                    (for performance - provide only if imprint is in                    loop - value should be same) Returns: None</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def imprint(self, item_id, data, all_items=None, items_meta=None):\n    \"\"\"\n        Save item metadata to Label field of metadata of active document\n    Args:\n        item_id (int|str): id of FootageItem or instance_id for workfiles\n        data(string): json representation for single layer\n        all_items (list of item): for performance, could be\n            injected for usage in loop, if not, single call will be\n            triggered\n        items_meta(string): json representation from Headline\n                       (for performance - provide only if imprint is in\n                       loop - value should be same)\n    Returns: None\n    \"\"\"\n    if not items_meta:\n        items_meta = self.get_metadata()\n\n    result_meta = []\n    # fix existing\n    is_new = True\n\n    for item_meta in items_meta:\n        if ((item_meta.get('members') and\n                str(item_id) == str(item_meta.get('members')[0])) or\n                item_meta.get(\"instance_id\") == item_id):\n            is_new = False\n            if data:\n                item_meta.update(data)\n                result_meta.append(item_meta)\n        else:\n            result_meta.append(item_meta)\n\n    if is_new:\n        result_meta.append(data)\n\n    # Ensure only valid ids are stored.\n    if not all_items:\n        # loaders create FootageItem now\n        all_items = self.get_items(comps=True,\n                                   folders=True,\n                                   footages=True)\n    item_ids = [int(item.id) for item in all_items]\n    cleaned_data = []\n    for meta in result_meta:\n        # do not added instance with nonexistend item id\n        if meta.get(\"members\"):\n            if int(meta[\"members\"][0]) not in item_ids:\n                continue\n\n        cleaned_data.append(meta)\n\n    payload = json.dumps(cleaned_data, indent=4)\n\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.imprint',\n                                     payload=payload))\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.open","title":"<code>open(path)</code>","text":"<pre><code>Open file located at 'path' (local).\n</code></pre> <p>Args:     path(string): file path locally Returns: None</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def open(self, path):\n    \"\"\"\n        Open file located at 'path' (local).\n    Args:\n        path(string): file path locally\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.open', path=path))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.print_msg","title":"<code>print_msg(msg)</code>","text":"<p>Triggers Javascript alert dialog.</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def print_msg(self, msg):\n    \"\"\"Triggers Javascript alert dialog.\"\"\"\n    self.websocketserver.call(self.client.call\n                              ('AfterEffects.print_msg',\n                               msg=msg))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.read","title":"<code>read(item, layers_meta=None)</code>","text":"<pre><code>Parses item metadata from Label field of active document.\nUsed as filter to pick metadata for specific 'item' only.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>AEItem</code> <p>pulled info from AE</p> required <code>layers_meta</code> <code>dict</code> <p>full list from Headline (load and inject for better performance in loops)</p> <code>None</code> <p>Returns:     (dict):</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def read(self, item, layers_meta=None):\n    \"\"\"\n        Parses item metadata from Label field of active document.\n        Used as filter to pick metadata for specific 'item' only.\n\n    Args:\n        item (AEItem): pulled info from AE\n        layers_meta (dict): full list from Headline\n            (load and inject for better performance in loops)\n    Returns:\n        (dict):\n    \"\"\"\n    if layers_meta is None:\n        layers_meta = self.get_metadata()\n    for item_meta in layers_meta:\n        if 'container' in item_meta.get('id') and \\\n                str(item.id) == str(item_meta.get('members')[0]):\n            return item_meta\n\n    self.log.debug(f\"Couldn't find layer metadata for item: {item}\")\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.reload_background","title":"<code>reload_background(comp_id, comp_name, files)</code>","text":"<p>Reloads backgrounds images to existing composition.</p> <p>It actually deletes complete folder with imported images and created composition for safety.</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> <p>id of existing composition to be overwritten</p> required <code>comp_name</code> <code>str</code> <p>new name of composition (could be same as old if version up only)</p> required <code>files</code> <code>list</code> <p>list of absolute paths to import and add as layers</p> required <p>Returns:     (AEItem): object with id of created folder, all imported images</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def reload_background(self, comp_id, comp_name, files):\n    \"\"\"\n        Reloads backgrounds images to existing composition.\n\n        It actually deletes complete folder with imported images and\n        created composition for safety.\n\n        Args:\n            comp_id (int): id of existing composition to be overwritten\n            comp_name (str): new name of composition (could be same as old\n                if version up only)\n            files (list): list of absolute paths to import and\n                add as layers\n        Returns:\n            (AEItem): object with id of created folder, all imported images\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.reload_background',\n                                     comp_id=comp_id,\n                                     comp_name=comp_name,\n                                     files=files))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.remove_instance","title":"<code>remove_instance(instance_id, metadata=None)</code>","text":"<p>Removes instance with 'instance_id' from file's metadata and saves them.</p> <p>Keep matching item in file though.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id(string)</code> <p>instance id</p> required Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def remove_instance(self, instance_id, metadata=None):\n    \"\"\"\n        Removes instance with 'instance_id' from file's metadata and\n        saves them.\n\n        Keep matching item in file though.\n\n        Args:\n            instance_id(string): instance id\n    \"\"\"\n    cleaned_data = []\n\n    if metadata is None:\n        metadata = self.get_metadata()\n\n    for instance in metadata:\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")\n        if inst_id != instance_id:\n            cleaned_data.append(instance)\n\n    payload = json.dumps(cleaned_data, indent=4)\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.imprint',\n                                     payload=payload))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.rename_item","title":"<code>rename_item(item_id, item_name)</code>","text":"<p>Replace item with item_name</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> required <code>item_name</code> <code>string</code> <p>label on item in Project list</p> required Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def rename_item(self, item_id, item_name):\n    \"\"\" Replace item with item_name\n\n        Args:\n            item_id (int):\n            item_name (string): label on item in Project list\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.rename_item',\n                                     item_id=item_id,\n                                     item_name=item_name))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.render","title":"<code>render(folder_url, comp_id)</code>","text":"<pre><code>Render all renderqueueitem to 'folder_url'\n</code></pre> <p>Args:     folder_url(string): local folder path for collecting Returns: None</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def render(self, folder_url, comp_id):\n    \"\"\"\n        Render all renderqueueitem to 'folder_url'\n    Args:\n        folder_url(string): local folder path for collecting\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.render',\n                                     folder_url=folder_url,\n                                     comp_id=comp_id))\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.replace_item","title":"<code>replace_item(item_id, path, item_name)</code>","text":"<p>Replace FootageItem with new file</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> required <code>path</code> <code>string</code> <p>absolute path</p> required <code>item_name</code> <code>string</code> <p>label on item in Project list</p> required Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def replace_item(self, item_id, path, item_name):\n    \"\"\" Replace FootageItem with new file\n\n        Args:\n            item_id (int):\n            path (string):absolute path\n            item_name (string): label on item in Project list\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.replace_item',\n                                     item_id=item_id,\n                                     path=path, item_name=item_name))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.save","title":"<code>save()</code>","text":"<pre><code>Saves active document\n</code></pre> <p>Returns: None</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def save(self):\n    \"\"\"\n        Saves active document\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.save'))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.saveAs","title":"<code>saveAs(project_path, as_copy)</code>","text":"<pre><code>Saves active project to aep (copy) or png or jpg\n</code></pre> <p>Args:     project_path(string): full local path     as_copy:  Returns: None Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def saveAs(self, project_path, as_copy):\n    \"\"\"\n        Saves active project to aep (copy) or png or jpg\n    Args:\n        project_path(string): full local path\n        as_copy: &lt;boolean&gt;\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.saveAs',\n                                     image_path=project_path,\n                                     as_copy=as_copy))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.select_items","title":"<code>select_items(items)</code>","text":"<pre><code>Select items in Project list\n</code></pre> <p>Args:     items (list): of int item ids</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def select_items(self, items):\n    \"\"\"\n        Select items in Project list\n    Args:\n        items (list): of int item ids\n    \"\"\"\n    self.websocketserver.call(\n        self.client.call('AfterEffects.select_items', items=items))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.set_comp_properties","title":"<code>set_comp_properties(comp_id, start, duration, frame_rate, width, height)</code>","text":"<pre><code>Set work area to predefined values (from Ftrack).\nWork area directs what gets rendered.\nBeware of rounding, AE expects seconds, not frames directly.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> required <code>start</code> <code>int</code> <p>workAreaStart in frames</p> required <code>duration</code> <code>int</code> <p>in frames</p> required <code>frame_rate</code> <code>float</code> <p>frames in seconds</p> required <code>width</code> <code>int</code> <p>resolution width</p> required <code>height</code> <code>int</code> <p>resolution height</p> required Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def set_comp_properties(self, comp_id, start, duration, frame_rate,\n                        width, height):\n    \"\"\"\n        Set work area to predefined values (from Ftrack).\n        Work area directs what gets rendered.\n        Beware of rounding, AE expects seconds, not frames directly.\n\n    Args:\n        comp_id (int):\n        start (int): workAreaStart in frames\n        duration (int): in frames\n        frame_rate (float): frames in seconds\n        width (int): resolution width\n        height (int): resolution height\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.set_comp_properties',\n                                     item_id=comp_id,\n                                     start=start,\n                                     duration=duration,\n                                     frame_rate=frame_rate,\n                                     width=width,\n                                     height=height))\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.AfterEffectsServerStub.set_label_color","title":"<code>set_label_color(item_id, color_idx)</code>","text":"<pre><code>Used for highlight additional information in Project panel.\nGreen color is loaded asset, blue is created asset\n</code></pre> <p>Args:     item_id (int):     color_idx (int): 0-16 Label colors from AE Project view</p> Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def set_label_color(self, item_id, color_idx):\n    \"\"\"\n        Used for highlight additional information in Project panel.\n        Green color is loaded asset, blue is created asset\n    Args:\n        item_id (int):\n        color_idx (int): 0-16 Label colors from AE Project view\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    ('AfterEffects.set_label_color',\n                                     item_id=item_id,\n                                     color_idx=color_idx))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/ws_stub.html#client.ayon_aftereffects.api.ws_stub.get_stub","title":"<code>get_stub()</code>","text":"<pre><code>Convenience function to get server RPC stub to call methods directed\nfor host (Photoshop).\nIt expects already created connection, started from client.\nCurrently, created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n</code></pre> <p>:return:  where functions could be called from Source code in <code>client/ayon_aftereffects/api/ws_stub.py</code> <pre><code>def get_stub():\n    \"\"\"\n        Convenience function to get server RPC stub to call methods directed\n        for host (Photoshop).\n        It expects already created connection, started from client.\n        Currently, created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n    :return: &lt;PhotoshopClientStub&gt; where functions could be called from\n    \"\"\"\n    ae_stub = AfterEffectsServerStub()\n    if not ae_stub.client:\n        raise ConnectionNotEstablishedYet(\"Connection is not created yet\")\n\n    return ae_stub\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/api/extension/index.html","title":"extension","text":""},{"location":"autoapi/client/ayon_aftereffects/api/extension/CSXS/index.html","title":"CSXS","text":""},{"location":"autoapi/client/ayon_aftereffects/api/extension/css/index.html","title":"css","text":""},{"location":"autoapi/client/ayon_aftereffects/api/extension/icons/index.html","title":"icons","text":""},{"location":"autoapi/client/ayon_aftereffects/api/extension/js/index.html","title":"js","text":""},{"location":"autoapi/client/ayon_aftereffects/api/extension/js/libs/index.html","title":"libs","text":""},{"location":"autoapi/client/ayon_aftereffects/api/extension/jsx/index.html","title":"jsx","text":""},{"location":"autoapi/client/ayon_aftereffects/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_aftereffects/hooks/pre_launch_args.html","title":"pre_launch_args","text":""},{"location":"autoapi/client/ayon_aftereffects/hooks/pre_launch_args.html#client.ayon_aftereffects.hooks.pre_launch_args.AEPrelaunchHook","title":"<code>AEPrelaunchHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch arguments preparation.</p> <p>Hook add python executable and script path to AE implementation before AE executable and add last workfile path to launch arguments.</p> <p>Existence of last workfile is checked. If workfile does not exists tries to copy templated workfile from predefined path.</p> Source code in <code>client/ayon_aftereffects/hooks/pre_launch_args.py</code> <pre><code>class AEPrelaunchHook(PreLaunchHook):\n    \"\"\"Launch arguments preparation.\n\n    Hook add python executable and script path to AE implementation before\n    AE executable and add last workfile path to launch arguments.\n\n    Existence of last workfile is checked. If workfile does not exists tries\n    to copy templated workfile from predefined path.\n    \"\"\"\n    app_groups = {\"aftereffects\"}\n\n    order = 20\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Pop executable\n        executable_path = self.launch_context.launch_args.pop(0)\n\n        # Pop rest of launch arguments - There should not be other arguments!\n        remainders = []\n        while self.launch_context.launch_args:\n            remainders.append(self.launch_context.launch_args.pop(0))\n\n        script_path = get_launch_script_path()\n\n        new_launch_args = get_ayon_launcher_args(\n            \"run\", script_path, executable_path\n        )\n        # Add workfile path if exists\n        workfile_path = self.data[\"last_workfile_path\"]\n        if (\n            self.data.get(\"start_last_workfile\")\n            and workfile_path\n            and os.path.exists(workfile_path)\n        ):\n            new_launch_args.append(workfile_path)\n\n        # Append as whole list as these arguments should not be separated\n        self.launch_context.launch_args.append(new_launch_args)\n\n        if remainders:\n            self.launch_context.launch_args.extend(remainders)\n\n        self.launch_context.kwargs = get_launch_kwargs(\n            self.launch_context.kwargs\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/hooks/pre_launch_args.html#client.ayon_aftereffects.hooks.pre_launch_args.get_launch_kwargs","title":"<code>get_launch_kwargs(kwargs)</code>","text":"<p>Explicit setting of kwargs for Popen for AfterEffects.</p> <p>Expected behavior - ayon_console opens window with logs - ayon has stdout/stderr available for capturing</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Union[dict, None]</code> <p>Current kwargs or None.</p> required Source code in <code>client/ayon_aftereffects/hooks/pre_launch_args.py</code> <pre><code>def get_launch_kwargs(kwargs):\n    \"\"\"Explicit setting of kwargs for Popen for AfterEffects.\n\n    Expected behavior\n    - ayon_console opens window with logs\n    - ayon has stdout/stderr available for capturing\n\n    Args:\n        kwargs (Union[dict, None]): Current kwargs or None.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    if platform.system().lower() != \"windows\":\n        return kwargs\n\n    if is_using_ayon_console():\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE\n        })\n    else:\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NO_WINDOW,\n            \"stdout\": subprocess.DEVNULL,\n            \"stderr\": subprocess.DEVNULL\n        })\n    return kwargs\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/hooks/pre_launch_install_ayon_extension.html","title":"pre_launch_install_ayon_extension","text":""},{"location":"autoapi/client/ayon_aftereffects/hooks/pre_launch_install_ayon_extension.html#client.ayon_aftereffects.hooks.pre_launch_install_ayon_extension.InstallAyonExtensionToAfterEffect","title":"<code>InstallAyonExtensionToAfterEffect</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Automatically 'installs' the AYON AfterEffects extension.</p> <p>Checks if AE already has the extension in the relevant folder, will try to create that folder and unzip the extension if not. Will compare versions if folder does exist, replacing if mismatched.</p> Source code in <code>client/ayon_aftereffects/hooks/pre_launch_install_ayon_extension.py</code> <pre><code>class InstallAyonExtensionToAfterEffect(PreLaunchHook):\n    \"\"\"\n    Automatically 'installs' the AYON AfterEffects extension.\n\n    Checks if AE already has the extension in the relevant folder,\n    will try to create that folder and unzip the extension if not.\n    Will compare versions if folder does exist, replacing if mismatched.\n    \"\"\"\n\n    app_groups = {\"aftereffects\"}\n\n    order = 1\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        try:\n            settings = self.data[\"project_settings\"][\"aftereffects\"]\n            if not settings[\"auto_install_extension\"]:\n                return\n            self.inner_execute()\n\n        except Exception:\n            self.log.warning(\n                \"Processing of {} crashed.\".format(self.__class__.__name__),\n                exc_info=True,\n            )\n\n    def inner_execute(self):\n        self.log.info(\"Installing AYON After Effects extension.\")\n\n        # Windows only for now.\n        if not platform.system().lower() == \"windows\":\n            self.log.info(\"Non Windows platform. Cancelling..\")\n            return\n\n        target_path = os.path.join(\n            os.environ[\"appdata\"],\n            \"Adobe\",\n            \"CEP\",\n            \"extensions\",\n            \"io.ynput.AE.panel\",\n        )\n\n        extension_path = os.path.join(\n            AFTEREFFECTS_ADDON_ROOT,\n            \"api\",\n            \"extension.zxp\",\n        )\n\n        # Extension already installed, compare the versions\n        if os.path.exists(target_path):\n            self.log.info(\n                f\"The extension already exists at: {target_path}. \"\n                f\"Comparing versions..\"\n            )\n            if not self._compare_extension_versions(\n                target_path, extension_path\n            ):\n                return\n\n        self.log.debug(f\"Creating directory: {target_path}\")\n        os.makedirs(target_path, exist_ok=True)\n\n        with ZipFile(extension_path, \"r\") as archive:\n            archive.extractall(path=target_path)\n\n        self.log.info(\"Successfully installed AYON extension\")\n\n    def _compare_extension_versions(\n        self, target_path: str, extension_path: str\n    ) -&gt; bool:\n        # opens the existing extension manifest to get the Version attr\n        with open(f\"{target_path}/CSXS/manifest.xml\", \"rb\") as xml_file:\n            installed_version = (\n                ET.parse(xml_file)\n                .getroot()\n                .attrib.get(\"ExtensionBundleVersion\")\n            )\n        self.log.debug(f\"Current extension version found: {installed_version}\")\n\n        if not installed_version:\n            self.log.warning(\n                \"Unable to resolve the currently installed extension \"\n                \"version. Cancelling..\"\n            )\n            return False\n\n        # opens the .zxp manifest to get the Version attribute.\n        with ZipFile(extension_path, \"r\") as archive:\n            xml_file = archive.open(\"CSXS/manifest.xml\")\n\n        new_version = (\n            ET.parse(xml_file).getroot().attrib.get(\"ExtensionBundleVersion\")\n        )\n        if not new_version:\n            self.log.warning(\n                \"Unable to resolve the new extension version. \" \"Cancelling..\"\n            )\n        self.log.debug(f\"New extension version found: {new_version}\")\n\n        # compare the two versions, a simple == is enough since\n        # we don't care if the version increments or decrements\n        # if they match nothing happens.\n        if installed_version == new_version:\n            self.log.info(\"Versions matched. Cancelling..\")\n            return False\n\n        # remove the existing addon\n        self.log.info(\"Version mismatch found. Removing old extensions..\")\n        rmtree(target_path)\n        return True\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/create/create_render.html","title":"create_render","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/create/create_render.html#client.ayon_aftereffects.plugins.create.create_render.RenderCreator","title":"<code>RenderCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Creates 'render' instance for publishing.</p> <p>Result of 'render' instance is video or sequence of images for particular composition based of configuration in its RenderQueue.</p> Source code in <code>client/ayon_aftereffects/plugins/create/create_render.py</code> <pre><code>class RenderCreator(Creator):\n    \"\"\"Creates 'render' instance for publishing.\n\n    Result of 'render' instance is video or sequence of images for particular\n    composition based of configuration in its RenderQueue.\n    \"\"\"\n    identifier = \"render\"\n    label = \"Render\"\n    product_type = \"render\"\n    description = \"Render creator\"\n    icon = \"eye\"\n\n    create_allow_context_change = True\n\n    rendering_targets = {\n        \"local\": \"Local machine rendering\",\n        \"farm\": \"Farm rendering\",\n        \"frames\": \"Use existing frames\"\n    }\n\n    # Settings\n    mark_for_review = True\n    force_setting_values = True\n    rename_comp_to_product_name = True\n\n    def create(self, product_name, data, pre_create_data):\n        stub = api.get_stub()  # only after After Effects is up\n\n        try:\n            _ = stub.get_active_document_full_name()\n        except ValueError:\n            raise CreatorError(\n                \"Please save workfile via Workfile app first!\"\n            )\n\n        if pre_create_data.get(\"use_selection\"):\n            comps = stub.get_selected_items(\n                comps=True, folders=False, footages=False\n            )\n        else:\n            comps = stub.get_items(comps=True, folders=False, footages=False)\n\n        if not comps:\n            raise CreatorError(\n                \"Nothing to create. Select composition in Project Bin if \"\n                \"'Use selection' is toggled or create at least \"\n                \"one composition.\"\n            )\n        use_composition_name = (pre_create_data.get(\"use_composition_name\") or\n                                len(comps) &gt; 1)\n\n        # Transfer certain attributes to creator attributes\n        creator_attributes = {\n            \"render_target\": pre_create_data[\"render_target\"],\n            \"mark_for_review\": pre_create_data[\"mark_for_review\"]\n        }\n\n        for comp in comps:\n            composition_name = re.sub(\n                \"[^{}]+\".format(PRODUCT_NAME_ALLOWED_SYMBOLS),\n                \"\",\n                comp.name\n            )\n            if use_composition_name:\n                if \"{composition}\" not in product_name.lower():\n                    product_name += \"{Composition}\"\n\n                dynamic_fill = prepare_template_data({\"composition\":\n                                                      composition_name})\n                comp_product_name = product_name.format(**dynamic_fill)\n                data[\"composition_name\"] = composition_name\n            else:\n                comp_product_name = re.sub(\n                    r\"\\{composition\\}\",\n                    \"\",\n                    product_name,\n                    flags=re.IGNORECASE\n                )\n\n            data[\"members\"] = [comp.id]\n            data[\"creator_attributes\"] = creator_attributes\n            if self.rename_comp_to_product_name:\n                data[\"orig_comp_name\"] = composition_name\n\n            new_instance = CreatedInstance(\n                self.product_type, comp_product_name, data, self\n            )\n\n            api.get_stub().imprint(new_instance.id,\n                                   new_instance.data_to_store())\n            self._add_instance_to_context(new_instance)\n\n            if self.rename_comp_to_product_name:\n                stub.rename_item(comp.id, comp_product_name)\n            if self.force_setting_values:\n                # Force fps, frame range and resolution of comp to match\n                # the target publish context attributes.\n                # Task is not required for an instance, so it may be not set\n                if data.get(\"task\"):\n                    entity = self.create_context.get_task_entity(\n                        folder_path=data[\"folderPath\"],\n                        task_name=data[\"task\"]\n                    )\n                else:\n                    entity = self.create_context.get_folder_entity(\n                        folder_path=data[\"folderPath\"]\n                    )\n                set_settings(\n                    frames=True,\n                    resolution=True,\n                    comp_ids=[comp.id],\n                    print_msg=False,\n                    entity=entity)\n\n    def get_pre_create_attr_defs(self):\n        output = [\n            BoolDef(\"use_selection\",\n                    tooltip=\"Composition for publishable instance should be \"\n                            \"selected by default.\",\n                    default=True, label=\"Use selection\"),\n            BoolDef(\"use_composition_name\",\n                    label=\"Use composition name in product\"),\n            UISeparatorDef(),\n            EnumDef(\n                \"render_target\",\n                items=self.rendering_targets,\n                label=\"Render target\"\n            ),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=self.mark_for_review\n            )\n        ]\n        return output\n\n    def get_instance_attr_defs(self):\n        return [\n            EnumDef(\n                \"render_target\",\n                items=self.rendering_targets,\n                label=\"Render target\"\n            ),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=False\n            )\n        ]\n\n    def collect_instances(self):\n        for instance_data in cache_and_get_instances(self):\n            # legacy instances have product_type=='render' or 'renderLocal', use them\n            creator_id = instance_data.get(\"creator_identifier\")\n            if not creator_id:\n                # NOTE this is for backwards compatibility but probably can be\n                #   removed\n                creator_id = instance_data.get(\"family\", \"\")\n                creator_id = creator_id.replace(\"Local\", \"\")\n\n            if creator_id == self.identifier:\n                instance_data = self._handle_legacy(instance_data)\n                instance = CreatedInstance.from_existing(\n                    instance_data, self\n                )\n                self._add_instance_to_context(instance)\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            api.get_stub().imprint(created_inst.get(\"instance_id\"),\n                                   created_inst.data_to_store())\n            name_change = _changes.get(\"productName\")\n            if self.rename_comp_to_product_name and name_change:\n                api.get_stub().rename_item(created_inst.data[\"members\"][0],\n                                           name_change.new_value)\n\n    def remove_instances(self, instances):\n        \"\"\"Removes metadata and renames to original comp name if available.\"\"\"\n        for instance in instances:\n            self._remove_instance_from_context(instance)\n            self.host.remove_instance(instance)\n\n            if self.rename_comp_to_product_name:\n                comp_id = instance.data[\"members\"][0]\n                comp = api.get_stub().get_item(comp_id)\n                orig_comp_name = instance.data.get(\"orig_comp_name\")\n                if comp:\n                    if orig_comp_name:\n                        new_comp_name = orig_comp_name\n                    else:\n                        new_comp_name = \"dummyCompName\"\n                    api.get_stub().rename_item(comp_id,\n                                               new_comp_name)\n\n    def apply_settings(self, project_settings):\n        plugin_settings = (\n            project_settings[\"aftereffects\"][\"create\"][\"RenderCreator\"]\n        )\n\n        self.mark_for_review = plugin_settings[\"mark_for_review\"]\n        self.default_variants = plugin_settings.get(\n            \"default_variants\",\n            plugin_settings.get(\"defaults\") or []\n        )\n        self.rename_comp_to_product_name = plugin_settings.get(\n            \"rename_comp_to_product_name\", self.rename_comp_to_product_name\n        )\n        self.force_setting_values = plugin_settings.get(\n            \"force_setting_values\", self.force_setting_values\n        )\n\n    def get_detail_description(self):\n        return \"\"\"Creator for Render instances\n\n        Main publishable item in AfterEffects will be of `render` product type.\n        Result of this item (instance) is picture sequence or video that could\n        be a final delivery product or loaded and used in another DCCs.\n\n        Select single composition and create instance of 'render' product type\n        or turn off 'Use selection' to create instance for all compositions.\n\n        'Use composition name in product' allows to explicitly add composition\n        name into created product name.\n\n        Position of composition name could be set in\n        `project_settings/global/tools/creator/product_name_profiles` with\n        some form of '{composition}' placeholder.\n\n        Composition name will be used implicitly if multiple composition should\n        be handled at same time.\n\n        If {composition} placeholder is not us 'product_name_profiles'\n        composition name will be capitalized and set at the end of\n        product name if necessary.\n\n        If composition name should be used, it will be cleaned up of characters\n        that would cause an issue in published file names.\n        \"\"\"\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        dynamic_data = {}\n        if instance is not None:\n            composition_name = instance.get(\"composition_name\")\n            if composition_name:\n                dynamic_data[\"composition\"] = composition_name\n        else:\n            dynamic_data[\"composition\"] = \"{composition}\"\n\n        return dynamic_data\n\n    def _handle_legacy(self, instance_data):\n        \"\"\"Converts old instances to new format.\"\"\"\n        if not instance_data.get(\"members\"):\n            instance_data[\"members\"] = [instance_data.get(\"uuid\")]\n\n        if instance_data.get(\"uuid\"):\n            # uuid not needed, replaced with unique instance_id\n            api.get_stub().remove_instance(instance_data.get(\"uuid\"))\n            instance_data.pop(\"uuid\")\n\n        if not instance_data.get(\"task\"):\n            instance_data[\"task\"] = self.create_context.get_current_task_name()\n\n        if not instance_data.get(\"creator_attributes\"):\n            is_old_farm = instance_data.get(\"family\") != \"renderLocal\"\n            instance_data[\"creator_attributes\"] = {\"farm\": is_old_farm}\n            instance_data[\"productType\"] = self.product_type\n\n        if instance_data[\"creator_attributes\"].get(\"mark_for_review\") is None:\n            instance_data[\"creator_attributes\"][\"mark_for_review\"] = True\n\n        farm = instance_data[\"creator_attributes\"].pop(\"farm\", None)\n        if farm is not None:\n            if farm:\n                instance_data[\"creator_attributes\"][\"render_target\"] = \"farm\"\n            else:\n                instance_data[\"creator_attributes\"][\"render_target\"] = \"local\"\n\n        return instance_data\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/create/create_render.html#client.ayon_aftereffects.plugins.create.create_render.RenderCreator.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Removes metadata and renames to original comp name if available.</p> Source code in <code>client/ayon_aftereffects/plugins/create/create_render.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Removes metadata and renames to original comp name if available.\"\"\"\n    for instance in instances:\n        self._remove_instance_from_context(instance)\n        self.host.remove_instance(instance)\n\n        if self.rename_comp_to_product_name:\n            comp_id = instance.data[\"members\"][0]\n            comp = api.get_stub().get_item(comp_id)\n            orig_comp_name = instance.data.get(\"orig_comp_name\")\n            if comp:\n                if orig_comp_name:\n                    new_comp_name = orig_comp_name\n                else:\n                    new_comp_name = \"dummyCompName\"\n                api.get_stub().rename_item(comp_id,\n                                           new_comp_name)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/create/workfile_creator.html","title":"workfile_creator","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/load/load_background.html","title":"load_background","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/load/load_background.html#client.ayon_aftereffects.plugins.load.load_background.BackgroundLoader","title":"<code>BackgroundLoader</code>","text":"<p>               Bases: <code>AfterEffectsLoader</code></p> <p>Load images from Background product type Creates for each background separate folder with all imported images from background json AND automatically created composition with layers, each layer for separate image.</p> <p>For each load container is created and stored in project (.aep) metadata</p> Source code in <code>client/ayon_aftereffects/plugins/load/load_background.py</code> <pre><code>class BackgroundLoader(api.AfterEffectsLoader):\n    \"\"\"\n        Load images from Background product type\n        Creates for each background separate folder with all imported images\n        from background json AND automatically created composition with layers,\n        each layer for separate image.\n\n        For each load container is created and stored in project (.aep)\n        metadata\n    \"\"\"\n    label = \"Load JSON Background\"\n    product_types = {\"background\"}\n    representations = {\"json\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n        stub = self.get_stub()\n        items = stub.get_items(comps=True)\n        existing_items = [layer.name.replace(stub.LOADED_ICON, '')\n                          for layer in items]\n\n        comp_name = get_unique_layer_name(\n            existing_items,\n            \"{}_{}\".format(context[\"folder\"][\"name\"], name))\n\n        path = self.filepath_from_context(context)\n        layers = get_background_layers(path)\n        if not layers:\n            raise ValueError(\"No layers found in {}\".format(path))\n\n        comp = stub.import_background(None, stub.LOADED_ICON + comp_name,\n                                      layers)\n\n        if not comp:\n            raise ValueError(\"Import background failed. \"\n                             \"Please contact support\")\n\n        self[:] = [comp]\n        namespace = namespace or comp_name\n\n        return api.containerise(\n            name,\n            namespace,\n            comp,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        stub = self.get_stub()\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        repre_entity = context[\"representation\"]\n\n        _ = container.pop(\"layer\")\n\n        # without iterator number (_001, 002...)\n        namespace_from_container = re.sub(r'_\\d{3}$', '',\n                                          container[\"namespace\"])\n        comp_name = \"{}_{}\".format(folder_name, product_name)\n\n        # switching assets\n        if namespace_from_container != comp_name:\n            items = stub.get_items(comps=True)\n            existing_items = [layer.name for layer in items]\n            comp_name = get_unique_layer_name(\n                existing_items,\n                \"{}_{}\".format(folder_name, product_name))\n        else:  # switching version - keep same name\n            comp_name = container[\"namespace\"]\n\n        path = get_representation_path(repre_entity)\n\n        layers = get_background_layers(path)\n        comp = stub.reload_background(container[\"members\"][1],\n                                      stub.LOADED_ICON + comp_name,\n                                      layers)\n\n        # update container\n        container[\"representation\"] = repre_entity[\"id\"]\n        container[\"name\"] = product_name\n        container[\"namespace\"] = comp_name\n        container[\"members\"] = comp.members\n\n        stub.imprint(comp.id, container)\n\n    def remove(self, container):\n        \"\"\"\n            Removes element from scene: deletes layer + removes from file\n            metadata.\n        Args:\n            container (dict): container to be removed - used to get layer_id\n        \"\"\"\n        stub = self.get_stub()\n        layer = container.pop(\"layer\")\n        stub.imprint(layer.id, {})\n        stub.delete_item(layer.id)\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/load/load_background.html#client.ayon_aftereffects.plugins.load.load_background.BackgroundLoader.remove","title":"<code>remove(container)</code>","text":"<pre><code>Removes element from scene: deletes layer + removes from file\nmetadata.\n</code></pre> <p>Args:     container (dict): container to be removed - used to get layer_id</p> Source code in <code>client/ayon_aftereffects/plugins/load/load_background.py</code> <pre><code>def remove(self, container):\n    \"\"\"\n        Removes element from scene: deletes layer + removes from file\n        metadata.\n    Args:\n        container (dict): container to be removed - used to get layer_id\n    \"\"\"\n    stub = self.get_stub()\n    layer = container.pop(\"layer\")\n    stub.imprint(layer.id, {})\n    stub.delete_item(layer.id)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/load/load_file.html","title":"load_file","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/load/load_file.html#client.ayon_aftereffects.plugins.load.load_file.FileLoader","title":"<code>FileLoader</code>","text":"<p>               Bases: <code>AfterEffectsLoader</code></p> <p>Load images</p> <p>Stores the imported product version in a container named after the folder.</p> Source code in <code>client/ayon_aftereffects/plugins/load/load_file.py</code> <pre><code>class FileLoader(api.AfterEffectsLoader):\n    \"\"\"Load images\n\n    Stores the imported product version in a container named after the folder.\n    \"\"\"\n    label = \"Load file\"\n\n    product_types = {\n        \"image\",\n        \"plate\",\n        \"render\",\n        \"prerender\",\n        \"review\",\n        \"audio\",\n    }\n    representations = {\"*\"}\n\n    def load(self, context, name=None, namespace=None, data=None):\n        stub = self.get_stub()\n        selected_folders = stub.get_selected_items(\n            comps=False, folders=True, footages=False)\n        if selected_folders:\n            stub.select_items([folder.id for folder in selected_folders])\n        layers = stub.get_items(comps=True, folders=True, footages=True)\n        existing_layers = [layer.name for layer in layers]\n        comp_name = get_unique_layer_name(\n            existing_layers, \"{}_{}\".format(\n                context[\"folder\"][\"name\"], name\n            )\n        )\n\n        import_options = {}\n\n        path = self.filepath_from_context(context)\n\n        if len(context[\"representation\"][\"files\"]) &gt; 1:\n            import_options['sequence'] = True\n\n        if not path:\n            repr_id = context[\"representation\"][\"id\"]\n            self.log.warning(\n                \"Representation id `{}` is failing to load\".format(repr_id))\n            return\n\n        path = path.replace(\"\\\\\", \"/\")\n        if '.psd' in path:\n            import_options['ImportAsType'] = 'ImportAsType.COMP'\n\n        comp = stub.import_file(path, stub.LOADED_ICON + comp_name,\n                                import_options)\n        if not comp:\n            self.log.warning(\n                \"Representation `{}` is failing to load\".format(path))\n            self.log.warning(\"Check host app for alert error.\")\n            return\n\n        self[:] = [comp]\n        namespace = namespace or comp_name\n        return api.containerise(\n            name,\n            namespace,\n            comp,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container, context):\n        stub = self.get_stub()\n        layer = container.pop(\"layer\")\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        repre_entity = context[\"representation\"]\n\n        namespace_from_container = re.sub(r'_\\d{3}$', '',\n                                          container[\"namespace\"])\n        layer_name = \"{}_{}\".format(folder_name, product_name)\n        #\n        if namespace_from_container != layer_name:\n            layers = stub.get_items(comps=True)\n            existing_layers = [layer.name for layer in layers]\n            layer_name = get_unique_layer_name(\n                existing_layers,\n                \"{}_{}\".format(folder_name, product_name))\n        else:  # switching version - keep same name\n            layer_name = container[\"namespace\"]\n        path = get_representation_path(repre_entity)\n\n        if len(repre_entity[\"files\"]) &gt; 1:\n           path = os.path.dirname(path)\n        # with aftereffects.maintained_selection():  # TODO\n        stub.replace_item(layer.id, path, stub.LOADED_ICON + layer_name)\n        stub.imprint(\n            layer.id, {\"representation\": repre_entity[\"id\"],\n                       \"name\": product_name,\n                       \"namespace\": layer_name}\n        )\n\n    def remove(self, container):\n        \"\"\"\n            Removes element from scene: deletes layer + removes from Headline\n        Args:\n            container (dict): container to be removed - used to get layer_id\n        \"\"\"\n        stub = self.get_stub()\n        layer = container.pop(\"layer\")\n        stub.imprint(layer.id, {})\n        stub.delete_item(layer.id)\n\n    def switch(self, container, context):\n        self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/load/load_file.html#client.ayon_aftereffects.plugins.load.load_file.FileLoader.remove","title":"<code>remove(container)</code>","text":"<pre><code>Removes element from scene: deletes layer + removes from Headline\n</code></pre> <p>Args:     container (dict): container to be removed - used to get layer_id</p> Source code in <code>client/ayon_aftereffects/plugins/load/load_file.py</code> <pre><code>def remove(self, container):\n    \"\"\"\n        Removes element from scene: deletes layer + removes from Headline\n    Args:\n        container (dict): container to be removed - used to get layer_id\n    \"\"\"\n    stub = self.get_stub()\n    layer = container.pop(\"layer\")\n    stub.imprint(layer.id, {})\n    stub.delete_item(layer.id)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/add_publish_highlight.html","title":"add_publish_highlight","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/add_publish_highlight.html#client.ayon_aftereffects.plugins.publish.add_publish_highlight.AddPublishHighlight","title":"<code>AddPublishHighlight</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Revert back rendered comp name and add publish highlight</p> Source code in <code>client/ayon_aftereffects/plugins/publish/add_publish_highlight.py</code> <pre><code>class AddPublishHighlight(pyblish.api.InstancePlugin):\n    \"\"\"\n        Revert back rendered comp name and add publish highlight\n    \"\"\"\n\n    label = \"Add render highlight\"\n    order = pyblish.api.IntegratorOrder + 8.0\n    hosts = [\"aftereffects\"]\n    families = [\"render.farm\"]\n    optional = True\n\n    def process(self, instance):\n        stub = get_stub()\n        item = instance.data\n        # comp name contains highlight icon\n        stub.rename_item(item[\"comp_id\"], item[\"comp_name\"])\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/closeAE.html","title":"closeAE","text":"<p>Close AE after publish. For Webpublishing only.</p>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/closeAE.html#client.ayon_aftereffects.plugins.publish.closeAE.CloseAE","title":"<code>CloseAE</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Close AE after publish. For Webpublishing only.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/closeAE.py</code> <pre><code>class CloseAE(pyblish.api.ContextPlugin):\n    \"\"\"Close AE after publish. For Webpublishing only.\n    \"\"\"\n\n    order = pyblish.api.IntegratorOrder + 14\n    label = \"Close AE\"\n    optional = True\n    active = True\n\n    hosts = [\"aftereffects\"]\n    targets = [\"automated\"]\n\n    def process(self, context):\n        self.log.info(\"CloseAE\")\n\n        stub = get_stub()\n        self.log.info(\"Shutting down AE\")\n        stub.save()\n        stub.close()\n        self.log.info(\"AE closed\")\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_audio.html","title":"collect_audio","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_audio.html#client.ayon_aftereffects.plugins.publish.collect_audio.CollectAudio","title":"<code>CollectAudio</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject audio file url for rendered composition into context. Needs to run AFTER 'collect_render'. Use collected comp_id to check if there is an AVLayer in this composition</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_audio.py</code> <pre><code>class CollectAudio(pyblish.api.ContextPlugin):\n    \"\"\"Inject audio file url for rendered composition into context.\n        Needs to run AFTER 'collect_render'. Use collected comp_id to check\n        if there is an AVLayer in this composition\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.499\n    label = \"Collect Audio\"\n    hosts = [\"aftereffects\"]\n\n    def process(self, context):\n        for instance in context:\n            if 'render.farm' in instance.data.get(\"families\", []):\n                comp_id = instance.data[\"comp_id\"]\n                if not comp_id:\n                    self.log.debug(\"No comp_id filled in instance\")\n                    continue\n                context.data[\"audioFile\"] = os.path.normpath(\n                    get_stub().get_audio_url(comp_id)\n                ).replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_current_file.html#client.ayon_aftereffects.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Current File\"\n    hosts = [\"aftereffects\"]\n\n    def process(self, context):\n        context.data[\"currentFile\"] = os.path.normpath(\n            get_stub().get_active_document_full_name()\n        ).replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_extension_version.html","title":"collect_extension_version","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_extension_version.html#client.ayon_aftereffects.plugins.publish.collect_extension_version.CollectExtensionVersion","title":"<code>CollectExtensionVersion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Pulls and compares version of installed extension.</p> <p>It is recommended to use same extension as in provided AYON code.</p> <p>Please use Anastasiy\u2019s Extension Manager or ZXPInstaller to update extension in case of an error.</p> <p>You can locate extension.zxp in your installed AYON After Effects code in <code>repos/ayon-aftereffects/api/extension.zxp</code>.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_extension_version.py</code> <pre><code>class CollectExtensionVersion(pyblish.api.ContextPlugin):\n    \"\"\"Pulls and compares version of installed extension.\n\n    It is recommended to use same extension as in provided AYON code.\n\n    Please use Anastasiy\u2019s Extension Manager or ZXPInstaller to update\n    extension in case of an error.\n\n    You can locate extension.zxp in your installed AYON After Effects code\n    in `repos/ayon-aftereffects/api/extension.zxp`.\n    \"\"\"\n    # This technically should be a validator, but other collectors might be\n    # impacted with usage of obsolete extension, so collector that runs first\n    # was chosen\n    order = pyblish.api.CollectorOrder - 0.5\n    label = \"Collect extension version\"\n    hosts = [\"aftereffects\"]\n\n    optional = True\n    active = True\n\n    def process(self, context):\n        installed_version = get_stub().get_extension_version()\n\n        if not installed_version:\n            raise ValueError(\"Unknown version, probably old extension\")\n\n        manifest_url = get_extension_manifest_path()\n\n        if not os.path.exists(manifest_url):\n            self.log.debug(\"Unable to locate extension manifest, not checking\")\n            return\n\n        expected_version = None\n        with open(manifest_url) as fp:\n            content = fp.read()\n            found = re.findall(r'(ExtensionBundleVersion=\")([0-9\\.]+)(\")',\n                               content)\n            if found:\n                expected_version = found[0][1]\n\n        if expected_version != installed_version:\n            msg = (\n                \"Expected version '{}' found '{}'\\n Please update\"\n                \" your installed extension, it might not work properly.\"\n            ).format(expected_version, installed_version)\n\n            raise ValueError(msg)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_render.html","title":"collect_render","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_render.html#client.ayon_aftereffects.plugins.publish.collect_render.CollectAERender","title":"<code>CollectAERender</code>","text":"<p>               Bases: <code>AbstractCollectRender</code></p> <p>Prepares RenderInstance.</p> <p>RenderInstance is meant to replace simple dictionaries to provide code assist and typing. (Currently used only in AE, Harmony though.)</p> <p>This must run after <code>collect_review</code>, but before Deadline plugins (which should be run only on renderable instances.)</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_render.py</code> <pre><code>class CollectAERender(publish.AbstractCollectRender):\n    \"\"\"Prepares RenderInstance.\n\n    RenderInstance is meant to replace simple dictionaries to provide code\n    assist and typing. (Currently used only in AE, Harmony though.)\n\n    This must run after `collect_review`, but before Deadline plugins (which\n    should be run only on renderable instances.)\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.125\n    label = \"Collect After Effects Render Layers\"\n    hosts = [\"aftereffects\"]\n\n    padding_width = 6\n    rendered_extension = 'png'\n\n    _stub = None\n\n    @classmethod\n    def get_stub(cls):\n        if not cls._stub:\n            cls._stub = get_stub()\n        return cls._stub\n\n    def get_instances(\n        self, context: pyblish.api.Context\n    ) -&gt; list[AERenderInstance]:\n        instances = []\n\n        app_version = CollectAERender.get_stub().get_app_version()\n        app_version = app_version[0:4]\n\n        current_file = context.data[\"currentFile\"]\n        version = context.data[\"version\"]\n\n        project_entity = context.data[\"projectEntity\"]\n\n        compositions = CollectAERender.get_stub().get_items(True)\n        compositions_by_id = {item.id: item for item in compositions}\n        for inst in context:\n            if not inst.data.get(\"active\", True):\n                continue\n\n            product_type = inst.data[\"productType\"]\n            if product_type not in [\"render\", \"renderLocal\"]:  # legacy\n                continue\n\n            comp_id = int(inst.data[\"members\"][0])\n\n            comp_info = CollectAERender.get_stub().get_comp_properties(\n                comp_id)\n\n            if not comp_info:\n                self.log.warning(\"Orphaned instance, deleting metadata\")\n                inst_id = inst.data.get(\"instance_id\") or str(comp_id)\n                CollectAERender.get_stub().remove_instance(inst_id)\n                continue\n\n            frame_start = comp_info.frameStart\n            frame_end = round(comp_info.frameStart +\n                              comp_info.framesDuration) - 1\n            fps = comp_info.frameRate\n            # TODO add resolution when supported by extension\n\n            task_name = inst.data.get(\"task\")\n\n            render_q = CollectAERender.get_stub().get_render_info(comp_id)\n            if not render_q:\n                raise PublishValidationError(\n                    \"No file extension set in Render Queue\")\n            render_item = render_q[0]\n\n            product_type = \"render\"\n            instance_families = inst.data.get(\"families\", [])\n            instance_families.append(product_type)\n            product_name = inst.data[\"productName\"]\n            instance = AERenderInstance(\n                productType=product_type,\n                family=product_type,\n                families=instance_families,\n                version=version,\n                time=\"\",\n                source=current_file,\n                label=\"{} - {}\".format(product_name, product_type),\n                productName=product_name,\n                folderPath=inst.data[\"folderPath\"],\n                task=task_name,\n                attachTo=False,\n                setMembers='',\n                publish=True,\n                name=product_name,\n                resolutionWidth=render_item.width,\n                resolutionHeight=render_item.height,\n                pixelAspect=1,\n                tileRendering=False,\n                tilesX=0,\n                tilesY=0,\n                review=\"review\" in instance_families,\n                frameStart=frame_start,\n                frameEnd=frame_end,\n                frameStep=1,\n                fps=fps,\n                app_version=app_version,\n                publish_attributes=inst.data.get(\"publish_attributes\", {}),\n                # one path per output module, could be multiple\n                render_queue_file_paths=[item.file_name for item in render_q],\n                # The source instance this render instance replaces\n                source_instance=inst\n            )\n\n            comp = compositions_by_id.get(comp_id)\n            if not comp:\n                raise ValueError(\"There is no composition for item {}\".\n                                 format(comp_id))\n            instance.outputDir = self._get_output_dir(instance)\n            instance.comp_name = comp.name\n            instance.comp_id = comp_id\n\n            creator_attributes = inst.data[\"creator_attributes\"]\n            if creator_attributes[\"render_target\"] == \"local\":\n                # for local renders\n                instance = self._update_for_local(instance, project_entity)\n            elif creator_attributes[\"render_target\"] == \"farm\":\n                fam = \"render.farm\"\n                if fam not in instance.families:\n                    instance.families.append(fam)\n                instance.renderer = \"aerender\"\n                instance.farm = True  # to skip integrate\n                if \"review\" in instance.families:\n                    # to skip ExtractReview locally\n                    instance.families.remove(\"review\")\n\n            instances.append(instance)\n\n        return instances\n\n    def get_expected_files(self, render_instance):\n        \"\"\"\n            Returns list of rendered files that should be created by\n            Deadline. These are not published directly, they are source\n            for later 'submit_publish_job'.\n\n        Args:\n            render_instance (AERenderInstance): to pull anatomy and parts used\n                in url\n\n        Returns:\n            (list) of absolute urls to rendered file\n        \"\"\"\n        start = render_instance.frameStart\n        end = render_instance.frameEnd\n\n        base_dir = self._get_output_dir(render_instance)\n        expected_files = []\n        for file_name in render_instance.render_queue_file_paths:\n            _, ext = os.path.splitext(os.path.basename(file_name))\n            ext = ext.replace('.', '')\n            version_str = \"v{:03d}\".format(render_instance.version)\n            if \"#\" not in file_name:  # single frame (mov)\n                file_name = \"{}_{}.{}\".format(\n                    render_instance.productName,\n                    version_str,\n                    ext\n                )\n                file_path = os.path.join(base_dir, file_name)\n                expected_files.append(file_path)\n            else:\n                for frame in range(start, end + 1):\n                    file_name = \"{}_{}.{}.{}\".format(\n                        render_instance.productName,\n                        version_str,\n                        str(frame).zfill(self.padding_width),\n                        ext\n                    )\n\n                    file_path = os.path.join(base_dir, file_name)\n                    expected_files.append(file_path)\n        return expected_files\n\n    def _get_output_dir(self, render_instance):\n        \"\"\"Return dir path of rendered files, used in submit_publish_job\n        for metadata.json location. Should be in separate folder inside work\n        area.\n\n        Args:\n            render_instance (AERenderInstance): The render instance.\n\n        Returns:\n            (str): absolute path to rendered files\n        \"\"\"\n        # render to folder of workfile\n        base_dir = os.path.dirname(render_instance.source)\n        file_name, _ = os.path.splitext(\n            os.path.basename(render_instance.source))\n        base_dir = os.path.join(base_dir, 'renders', 'aftereffects', file_name)\n\n        # for submit_publish_job\n        return base_dir\n\n    def _update_for_local(self, instance, project_entity):\n        \"\"\"Update old saved instances to current publishing format\"\"\"\n        instance.stagingDir = tempfile.mkdtemp()\n        instance.projectEntity = project_entity\n        fam = \"render.local\"\n        if fam not in instance.families:\n            instance.families.append(fam)\n\n        return instance\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_render.html#client.ayon_aftereffects.plugins.publish.collect_render.CollectAERender.get_expected_files","title":"<code>get_expected_files(render_instance)</code>","text":"<pre><code>Returns list of rendered files that should be created by\nDeadline. These are not published directly, they are source\nfor later 'submit_publish_job'.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>render_instance</code> <code>AERenderInstance</code> <p>to pull anatomy and parts used in url</p> required <p>Returns:</p> Type Description <p>(list) of absolute urls to rendered file</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_render.py</code> <pre><code>def get_expected_files(self, render_instance):\n    \"\"\"\n        Returns list of rendered files that should be created by\n        Deadline. These are not published directly, they are source\n        for later 'submit_publish_job'.\n\n    Args:\n        render_instance (AERenderInstance): to pull anatomy and parts used\n            in url\n\n    Returns:\n        (list) of absolute urls to rendered file\n    \"\"\"\n    start = render_instance.frameStart\n    end = render_instance.frameEnd\n\n    base_dir = self._get_output_dir(render_instance)\n    expected_files = []\n    for file_name in render_instance.render_queue_file_paths:\n        _, ext = os.path.splitext(os.path.basename(file_name))\n        ext = ext.replace('.', '')\n        version_str = \"v{:03d}\".format(render_instance.version)\n        if \"#\" not in file_name:  # single frame (mov)\n            file_name = \"{}_{}.{}\".format(\n                render_instance.productName,\n                version_str,\n                ext\n            )\n            file_path = os.path.join(base_dir, file_name)\n            expected_files.append(file_path)\n        else:\n            for frame in range(start, end + 1):\n                file_name = \"{}_{}.{}.{}\".format(\n                    render_instance.productName,\n                    version_str,\n                    str(frame).zfill(self.padding_width),\n                    ext\n                )\n\n                file_path = os.path.join(base_dir, file_name)\n                expected_files.append(file_path)\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_rendered_files.html","title":"collect_rendered_files","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_rendered_files.html#client.ayon_aftereffects.plugins.publish.collect_rendered_files.CollectExistingFrames","title":"<code>CollectExistingFrames</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect existing files rendered via Render in Render Queues.</p> <p>These files might exist there from test render, triggered manually by artist, now its only about collecting and publishing them to save time.</p> <p>This is prepared for multiple output modules in Render Queue, which is not currently allowed, but might be in the future. It is expected if there are multiple output modules per Render Queue, they must have different extension!</p> <p>Prepares representations to allow integration later.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_rendered_files.py</code> <pre><code>class CollectExistingFrames(pyblish.api.InstancePlugin):\n    \"\"\"Collect existing files rendered via Render in Render Queues.\n\n    These files might exist there from test render, triggered manually by\n    artist, now its only about collecting and publishing them to save time.\n\n    This is prepared for multiple output modules in Render Queue, which is not\n    currently allowed, but might be in the future.\n    It is expected if there are multiple output modules per Render Queue,\n    they must have different extension!\n\n    Prepares representations to allow integration later.\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.150\n    label = \"Collect After Effects Existing Frames\"\n    hosts = [\"aftereffects\"]\n    families = [\"render\"]\n\n    settings_category = \"aftereffects\"\n\n    def process(self, instance):\n        use_existing_frames = (\n            instance.data[\"creator_attributes\"]\n                         [\"render_target\"] == \"frames\"\n        )\n\n        if not use_existing_frames:\n            self.log.debug(\"Not using existing frames, skipping\")\n            return\n\n        render_queue_file_paths = instance.data[\"render_queue_file_paths\"]\n        files_by_ext = collections.defaultdict(list)\n        folders_by_ext = collections.defaultdict(list)\n        expected_files = []\n        for render_queue_file_path in render_queue_file_paths:\n            render_queue_file_path = (\n                self._normalize_path(render_queue_file_path))\n\n            render_queue_folder = os.path.dirname(render_queue_file_path)\n            if not os.path.exists(render_queue_folder):\n                self.log.warning(f\"{render_queue_folder} doesn't exist.\")\n                continue\n\n            _, render_queue_extension = (\n                os.path.splitext(os.path.basename(render_queue_file_path))\n            )\n            render_queue_extension = render_queue_extension.lstrip(\".\")\n\n            self._add_expected_files(\n                instance, render_queue_file_path, expected_files)\n\n            if render_queue_extension in folders_by_ext:\n                raise KnownPublishError(\n                    \"Multiple render queues detected \"\n                    \"with same extension. \\n\"\n                    \"Please change one of the extensions!\"\n                )\n\n            folders_by_ext[render_queue_extension] = render_queue_folder\n            self.log.debug(f\"Searching for files in '{render_queue_folder}'\")\n            for file_name in os.listdir(render_queue_folder):\n                if not file_name.endswith(render_queue_extension):\n                    continue\n                files_by_ext[render_queue_extension].append(file_name)\n\n        if not files_by_ext:\n            self.log.warning(\"No expected files collected, \"\n                             \"problem with render directory.\")\n            return\n\n        representations = []\n        for ext, files in files_by_ext.items():\n            # single file cannot be wrapped in array\n            resulting_files = files\n            if len(files) == 1:\n                resulting_files = files[0]\n\n            repre_data = {\n                \"frameStart\": instance.data[\"frameStart\"],\n                \"frameEnd\": instance.data[\"frameEnd\"],\n                \"name\": ext,\n                \"ext\": ext,\n                \"files\": resulting_files,\n                \"stagingDir\": folders_by_ext[ext]\n            }\n            first_repre = not representations\n            if instance.data[\"review\"] and first_repre:\n                repre_data[\"tags\"] = [\"review\"]\n                # TODO return back when Extract from source same as regular\n                # thumbnail_path = os.path.join(staging_dir, files[0])\n                # instance.data[\"thumbnailSource\"] = thumbnail_path\n\n            representations.append(repre_data)\n\n        instance.data[\"representations\"] = representations\n        instance.data[\"expectedFiles\"] = expected_files\n\n    def _add_expected_files(self, instance, render_queue_path, expected_files):\n        \"\"\"Calculate expected files from file patterns in Render Queue\"\"\"\n        render_queue_path = urllib.parse.unquote(render_queue_path)\n        frames_pattern = re.search(\"\\[#*\\]\", render_queue_path)\n\n        if not frames_pattern:\n            expected_files.append(render_queue_path)\n            return\n\n        frames_pattern = frames_pattern.group()\n\n        frame_start = instance.data[\"frameStart\"]\n        frame_end = instance.data[\"frameEnd\"]\n\n        frames_length = frames_pattern.count(\"#\")\n        for frame in range(frame_start, frame_end + 1):\n            frame_str = \"%0*d\" % (frames_length, int(frame))\n            render_queue_path = render_queue_path.replace(\n                frames_pattern, frame_str)\n            expected_files.append(render_queue_path)\n\n\n    def _normalize_path(self, path):\n        \"\"\"AE might return path like '/c/Users/...', convert to proper path\"\"\"\n        current_platform = platform.system().lower()\n        if current_platform == \"windows\" and path.startswith(\"/\"):\n            path = path.lstrip(\"/\")\n            first_slash_index = path.find(\"/\")\n            path = f\"{path[0:first_slash_index]}:{path[first_slash_index:]}\"\n\n        path = os.path.expanduser(path)\n\n        return os.path.normpath(path)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_review.html","title":"collect_review","text":"Requires <p>None</p> Provides <p>instance     -&gt; families (\"review\")</p>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_review.html#client.ayon_aftereffects.plugins.publish.collect_review.CollectReview","title":"<code>CollectReview</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Add review to families if instance created with 'mark_for_review' flag</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_review.py</code> <pre><code>class CollectReview(pyblish.api.ContextPlugin):\n    \"\"\"Add review to families if instance created with 'mark_for_review' flag\n    \"\"\"\n    label = \"Collect Review\"\n    hosts = [\"aftereffects\"]\n    order = pyblish.api.CollectorOrder + 0.1\n    settings_category = \"aftereffects\"\n\n    def process(self, context):\n        for instance in context:\n            creator_attributes = instance.data.get(\"creator_attributes\") or {}\n            if (\n                creator_attributes.get(\"mark_for_review\")\n                and \"review\" not in instance.data[\"families\"]\n            ):\n                instance.data[\"families\"].append(\"review\")\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/collect_workfile.html#client.ayon_aftereffects.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Workfile representation.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Collect Workfile representation.\"\"\"\n\n    label = \"Collect After Effects Workfile\"\n    order = pyblish.api.CollectorOrder + 0.1\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        current_file = instance.context.data[\"currentFile\"]\n        staging_dir = os.path.dirname(current_file)\n        scene_file = os.path.basename(current_file)\n\n        # creating representation\n        instance.data.setdefault(\"representations\", []).append({\n            \"name\": \"aep\",\n            \"ext\": \"aep\",\n            \"files\": scene_file,\n            \"stagingDir\": staging_dir,\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/extract_compositions.html","title":"extract_compositions","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/extract_compositions.html#client.ayon_aftereffects.plugins.publish.extract_compositions.ExtractSaveScene","title":"<code>ExtractSaveScene</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collects all compositions contained in workfile.</p> <p>Used later in Premiere to choose which composition to load.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/extract_compositions.py</code> <pre><code>class ExtractSaveScene(pyblish.api.InstancePlugin):\n    \"\"\"Collects all compositions contained in workfile.\n\n    Used later in Premiere to choose which composition to load.\n    \"\"\"\n\n    order = publish.Extractor.order\n    label = \"Extract Compositions\"\n    hosts = [\"aftereffects\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n        stub = get_stub()\n        representation = instance.data[\"representations\"][0]\n\n        comp_items =  stub.get_items(\n            comps=True,\n            folders=False,\n            footages=False\n        )\n        if \"data\" not in representation:\n            representation[\"data\"] = {}\n        data = {\n            \"composition_names_in_workfile\": [item.name for item in comp_items]\n        }\n        representation[\"data\"].update(data)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/extract_local_render.html","title":"extract_local_render","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/extract_local_render.html#client.ayon_aftereffects.plugins.publish.extract_local_render.ExtractLocalRender","title":"<code>ExtractLocalRender</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Render RenderQueue locally.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/extract_local_render.py</code> <pre><code>class ExtractLocalRender(publish.Extractor):\n    \"\"\"Render RenderQueue locally.\"\"\"\n\n    order = publish.Extractor.order - 0.47\n    label = \"Extract Local Render\"\n    hosts = [\"aftereffects\"]\n    families = [\"renderLocal\", \"render.local\"]\n\n    def process(self, instance):\n        stub = get_stub()\n        staging_dir = instance.data[\"stagingDir\"]\n        self.log.debug(\"staging_dir::{}\".format(staging_dir))\n\n        # pull file name collected value from Render Queue Output module\n        if not instance.data[\"render_queue_file_paths\"]:\n            raise ValueError(\"No file extension set in Render Queue\")\n\n        comp_id = instance.data['comp_id']\n        stub.render(staging_dir, comp_id)\n\n        representations = []\n        for file_name in instance.data[\"render_queue_file_paths\"]:\n            _, ext = os.path.splitext(os.path.basename(file_name))\n            ext = ext[1:]\n\n            first_file_path = None\n            files = []\n            for found_file_name in os.listdir(staging_dir):\n                if not found_file_name.endswith(ext):\n                    continue\n\n                files.append(found_file_name)\n                if first_file_path is None:\n                    first_file_path = os.path.join(staging_dir,\n                                                   found_file_name)\n\n            if not files:\n                self.log.info(\"no files\")\n                return\n\n            # single file cannot be wrapped in array\n            resulting_files = files\n            if len(files) == 1:\n                resulting_files = files[0]\n\n            repre_data = {\n                \"frameStart\": instance.data[\"frameStart\"],\n                \"frameEnd\": instance.data[\"frameEnd\"],\n                \"name\": ext,\n                \"ext\": ext,\n                \"files\": resulting_files,\n                \"stagingDir\": staging_dir\n            }\n            first_repre = not representations\n            if instance.data[\"review\"] and first_repre:\n                repre_data[\"tags\"] = [\"review\"]\n                # TODO return back when Extract from source same as regular\n                # thumbnail_path = os.path.join(staging_dir, files[0])\n                # instance.data[\"thumbnailSource\"] = thumbnail_path\n\n            representations.append(repre_data)\n\n        instance.data[\"representations\"] = representations\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/extract_save_scene.html","title":"extract_save_scene","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/extract_save_scene.html#client.ayon_aftereffects.plugins.publish.extract_save_scene.ExtractSaveScene","title":"<code>ExtractSaveScene</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save scene before extraction.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/extract_save_scene.py</code> <pre><code>class ExtractSaveScene(pyblish.api.ContextPlugin):\n    \"\"\"Save scene before extraction.\"\"\"\n\n    order = publish.Extractor.order - 0.48\n    label = \"Extract Save Scene\"\n    hosts = [\"aftereffects\"]\n\n    def process(self, context):\n        stub = get_stub()\n        stub.save()\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/increment_workfile.html","title":"increment_workfile","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/increment_workfile.html#client.ayon_aftereffects.plugins.publish.increment_workfile.IncrementWorkfile","title":"<code>IncrementWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Increment the current workfile.</p> <p>Saves the current scene with an increased version number.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/increment_workfile.py</code> <pre><code>class IncrementWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Increment the current workfile.\n\n    Saves the current scene with an increased version number.\n    \"\"\"\n\n    label = \"Increment Workfile\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    hosts = [\"aftereffects\"]\n    families = [\"workfile\"]\n    optional = True\n\n    def process(self, instance):\n        errored_plugins = get_errored_plugins_from_context(instance.context)\n        if errored_plugins:\n            raise RuntimeError(\n                \"Skipping incrementing current file because publishing failed.\"\n            )\n\n        scene_path = version_up(instance.context.data[\"currentFile\"])\n        get_stub().saveAs(scene_path, True)\n\n        self.log.info(\"Incremented workfile to: {}\".format(scene_path))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/remove_publish_highlight.html","title":"remove_publish_highlight","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/remove_publish_highlight.html#client.ayon_aftereffects.plugins.publish.remove_publish_highlight.RemovePublishHighlight","title":"<code>RemovePublishHighlight</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Clean utf characters which are not working in DL</p> <p>Published compositions are marked with unicode icon which causes problems on specific render environments. Clean it first, sent to rendering, add it later back to avoid confusion.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/remove_publish_highlight.py</code> <pre><code>class RemovePublishHighlight(publish.Extractor):\n    \"\"\"Clean utf characters which are not working in DL\n\n        Published compositions are marked with unicode icon which causes\n        problems on specific render environments. Clean it first, sent to\n        rendering, add it later back to avoid confusion.\n    \"\"\"\n\n    order = publish.Extractor.order - 0.49  # just before save\n    label = \"Clean render comp\"\n    hosts = [\"aftereffects\"]\n    families = [\"render.farm\"]\n\n    def process(self, instance):\n        stub = get_stub()\n        self.log.debug(\"instance::{}\".format(instance.data))\n        item = instance.data\n        comp_name = item[\"comp_name\"].replace(stub.PUBLISH_ICON, '')\n        stub.rename_item(item[\"comp_id\"], comp_name)\n        instance.data[\"comp_name\"] = comp_name\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_footage_items.html","title":"validate_footage_items","text":"<p>Validate presence of footage items in composition Requires:</p>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_footage_items.html#client.ayon_aftereffects.plugins.publish.validate_footage_items.ValidateFootageItems","title":"<code>ValidateFootageItems</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <pre><code>Validates if FootageItems contained in composition exist.\n</code></pre> <p>AE fails silently and doesn't render anything if footage item file is missing. This will result in nonresponsiveness of AE UI as it expects reaction from user, but it will not provide dialog. This validator tries to check existence of the files. It will not protect from missing frame in multiframes though (as AE api doesn't provide this information and it cannot be told how many frames should be there easily). Missing frame is replaced by placeholder.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_footage_items.py</code> <pre><code>class ValidateFootageItems(pyblish.api.InstancePlugin):\n    \"\"\"\n        Validates if FootageItems contained in composition exist.\n\n    AE fails silently and doesn't render anything if footage item file is\n    missing. This will result in nonresponsiveness of AE UI as it expects\n    reaction from user, but it will not provide dialog.\n    This validator tries to check existence of the files.\n    It will not protect from missing frame in multiframes though\n    (as AE api doesn't provide this information and it cannot be told how many\n    frames should be there easily). Missing frame is replaced by placeholder.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Footage Items\"\n    families = [\"render.farm\", \"render.local\", \"render\"]\n    hosts = [\"aftereffects\"]\n    optional = True\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n\n        comp_id = instance.data[\"comp_id\"]\n        for footage_item in get_stub().get_items(\n                comps=False, folders=False, footages=True):\n            self.log.debug(f\"Validating footage item: {footage_item.name}\")\n            if comp_id not in footage_item.containing_comps:\n                continue\n\n            path = footage_item.path\n            if path and not os.path.exists(path):\n                msg = f\"File {path} not found.\"\n                formatting = {\"name\": footage_item.name, \"path\": path}\n                raise PublishXmlValidationError(\n                    self, msg, formatting_data=formatting)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_footage_items.html#client.ayon_aftereffects.plugins.publish.validate_footage_items.ValidateFootageItems.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_footage_items.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n\n    comp_id = instance.data[\"comp_id\"]\n    for footage_item in get_stub().get_items(\n            comps=False, folders=False, footages=True):\n        self.log.debug(f\"Validating footage item: {footage_item.name}\")\n        if comp_id not in footage_item.containing_comps:\n            continue\n\n        path = footage_item.path\n        if path and not os.path.exists(path):\n            msg = f\"File {path} not found.\"\n            formatting = {\"name\": footage_item.name, \"path\": path}\n            raise PublishXmlValidationError(\n                self, msg, formatting_data=formatting)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_instance_folder.html","title":"validate_instance_folder","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_instance_folder.html#client.ayon_aftereffects.plugins.publish.validate_instance_folder.ValidateInstanceFolder","title":"<code>ValidateInstanceFolder</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate the instance folder is the current selected context folder.</p> <p>As it might happen that multiple worfiles are opened at same time, switching between them would mess with selected context. (From Launcher or Ftrack).</p> <p>In that case outputs might be output under wrong folder!</p> <p>Repair action will use Context folder value (from Workfiles or Launcher) Closing and reopening with Workfiles will refresh  Context value.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_instance_folder.py</code> <pre><code>class ValidateInstanceFolder(pyblish.api.InstancePlugin):\n    \"\"\"Validate the instance folder is the current selected context folder.\n\n        As it might happen that multiple worfiles are opened at same time,\n        switching between them would mess with selected context. (From Launcher\n        or Ftrack).\n\n        In that case outputs might be output under wrong folder!\n\n        Repair action will use Context folder value (from Workfiles or Launcher)\n        Closing and reopening with Workfiles will refresh  Context value.\n    \"\"\"\n\n    label = \"Validate Instance Folder\"\n    hosts = [\"aftereffects\"]\n    actions = [ValidateInstanceFolderRepair]\n    order = ValidateContentsOrder\n\n    def process(self, instance):\n        instance_folder = instance.data[\"folderPath\"]\n        current_folder = get_current_folder_path()\n\n        if instance_folder != current_folder:\n            raise PublishXmlValidationError(self, (\n                f\"Instance folder {instance_folder} is not the same \"\n                f\"as current context {current_folder}.\"\n            ))\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_instance_folder.html#client.ayon_aftereffects.plugins.publish.validate_instance_folder.ValidateInstanceFolderRepair","title":"<code>ValidateInstanceFolderRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the instance folder with value from Context.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_instance_folder.py</code> <pre><code>class ValidateInstanceFolderRepair(pyblish.api.Action):\n    \"\"\"Repair the instance folder with value from Context.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n\n        # Get the errored instances\n        failed = []\n        for result in context.data[\"results\"]:\n            if (result[\"error\"] is not None and result[\"instance\"] is not None\n                    and result[\"instance\"] not in failed):\n                failed.append(result[\"instance\"])\n\n        # Apply pyblish.logic to get the instances for the plug-in\n        instances = pyblish.api.instances_by_plugin(failed, plugin)\n        stub = get_stub()\n        for instance in instances:\n            data = stub.read(instance[0])\n\n            data[\"folderPath\"] = get_current_folder_path()\n            stub.imprint(instance[0].instance_id, data)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_rendered_files.html","title":"validate_rendered_files","text":"<p>Validate collected and expected files Requires:</p>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_rendered_files.html#client.ayon_aftereffects.plugins.publish.validate_rendered_files.ValidateRenderedFiles","title":"<code>ValidateRenderedFiles</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates if locally pre rendered files are all as expected.</p> <p>Artists might render manually with AE<code>Render</code> button and want only to publish these files after visually checking them. This validator checks that there exists files with same names as were expected to be rendered.</p> <p>Applies only on instances created with 'Use existing frames'.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_rendered_files.py</code> <pre><code>class ValidateRenderedFiles(pyblish.api.InstancePlugin):\n    \"\"\"Validates if locally pre rendered files are all as expected.\n\n    Artists might render manually with AE`Render` button and want only to\n    publish these files after visually checking them.\n    This validator checks that there exists files with same names as were\n    expected to be rendered.\n\n    Applies only on instances created with 'Use existing frames'.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Rendered Files\"\n    families = [\"render\"]\n    hosts = [\"aftereffects\"]\n    actions = [RepairAction]\n    optional = True\n\n    def process(self, instance):\n        \"\"\"Plugin entry point.\"\"\"\n        use_existing_frames = (\n            instance.data[\"creator_attributes\"]\n                         [\"render_target\"] == \"frames\"\n        )\n\n        if not use_existing_frames:\n            self.log.debug(\"Not using existing frames, skipping\")\n            return\n\n        expected_files = {os.path.basename(file_path)\n                          for file_path in instance.data[\"expectedFiles\"]}\n\n        collected_files = self._get_collected_files(instance)\n\n        # prepared for multiple outputs per render queue, now it will be only\n        # single folder\n        checked_folders = self._get_checked_folders(instance)\n\n        missing = expected_files - collected_files\n        if missing:\n            raise PublishValidationError(\n                \"&lt;b&gt;Checked:&lt;/b&gt; {}&lt;br/&gt;&lt;br/&gt;\"\n                \"&lt;b&gt;Missing expected files:&lt;/b&gt; {}&lt;br/&gt;&lt;br/&gt;\"\n                \"Expected files: {}&lt;br/&gt;\"\n                \"Existing files: {}\".format(\n                    sorted(checked_folders),\n                    sorted(missing),\n                    sorted(expected_files),\n                    sorted(collected_files)\n                )\n            )\n        else:\n            self.log.debug(\"Matching expected and found files\")\n\n        collections, remainders = (\n            self._get_collections_and_remainders(collected_files))\n\n        if remainders:\n            raise PublishValidationError(\n                f\"Folders {checked_folders} contain out of sequence files \"\n                f\"{remainders}. &lt;br/&gt;&lt;br/&gt;\"\n                f\"This will cause issue when integrating.&lt;br/&gt;&lt;br/&gt;\"\n                \"Please remove these files manually or use `Repair` action to \"\n                \"delete them.\"\n            )\n\n        if len(collections) &gt; 1:\n            raise PublishValidationError(\n                f\"Folders {checked_folders} contain multiple collections \"\n                f\"{collections}. &lt;br/&gt;&lt;br/&gt;\"\n                f\"This will cause issue during extraction of review.&lt;br/&gt;&lt;br/&gt;\"\n                \"Please remove one of the collections manually!\"\n            )\n\n    @classmethod\n    def _get_checked_folders(cls, instance):\n        \"\"\"Parses physical output dirs from Render Queue Output Module(s)\"\"\"\n        checked_folders = {os.path.dirname(file_path)\n                           for file_path in instance.data[\"expectedFiles\"]}\n        return checked_folders\n\n    @classmethod\n    def _get_collections_and_remainders(cls, collected_files):\n        \"\"\"Looks for similarly named files outside of collected sequence.\n\n        Could cause an issue in ExtractReview or Integrate.\n        \"\"\"\n        return clique.assemble(collected_files)\n\n    @classmethod\n    def _get_collected_files(cls, instance):\n        \"\"\"Returns all physically found frames for output dir(s)\"\"\"\n        collected_files = []\n        for repre in instance.data[\"representations\"]:\n            repre_files = repre[\"files\"]\n            if isinstance(repre_files, str):\n                repre_files = [repre_files]\n\n            collected_files.extend(repre_files)\n        collected_files = set(collected_files)\n        return collected_files\n\n    @classmethod\n    def repair(cls, instance):\n        \"\"\"Deletes out of sequence files from output dir(s).\"\"\"\n        collected_files = cls._get_collected_files(instance)\n        checked_folders = cls._get_checked_folders(instance)\n\n        _, remainders = cls._get_collections_and_remainders(collected_files)\n\n        for remainder_file_name in remainders:\n            for checked_folder in checked_folders:\n                file_path = os.path.join(checked_folder, remainder_file_name)\n                if os.path.exists(file_path):\n                    cls.log.warning(f\"Removing {file_path}\")\n                    os.remove(file_path)\n                    continue\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_rendered_files.html#client.ayon_aftereffects.plugins.publish.validate_rendered_files.ValidateRenderedFiles.process","title":"<code>process(instance)</code>","text":"<p>Plugin entry point.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_rendered_files.py</code> <pre><code>def process(self, instance):\n    \"\"\"Plugin entry point.\"\"\"\n    use_existing_frames = (\n        instance.data[\"creator_attributes\"]\n                     [\"render_target\"] == \"frames\"\n    )\n\n    if not use_existing_frames:\n        self.log.debug(\"Not using existing frames, skipping\")\n        return\n\n    expected_files = {os.path.basename(file_path)\n                      for file_path in instance.data[\"expectedFiles\"]}\n\n    collected_files = self._get_collected_files(instance)\n\n    # prepared for multiple outputs per render queue, now it will be only\n    # single folder\n    checked_folders = self._get_checked_folders(instance)\n\n    missing = expected_files - collected_files\n    if missing:\n        raise PublishValidationError(\n            \"&lt;b&gt;Checked:&lt;/b&gt; {}&lt;br/&gt;&lt;br/&gt;\"\n            \"&lt;b&gt;Missing expected files:&lt;/b&gt; {}&lt;br/&gt;&lt;br/&gt;\"\n            \"Expected files: {}&lt;br/&gt;\"\n            \"Existing files: {}\".format(\n                sorted(checked_folders),\n                sorted(missing),\n                sorted(expected_files),\n                sorted(collected_files)\n            )\n        )\n    else:\n        self.log.debug(\"Matching expected and found files\")\n\n    collections, remainders = (\n        self._get_collections_and_remainders(collected_files))\n\n    if remainders:\n        raise PublishValidationError(\n            f\"Folders {checked_folders} contain out of sequence files \"\n            f\"{remainders}. &lt;br/&gt;&lt;br/&gt;\"\n            f\"This will cause issue when integrating.&lt;br/&gt;&lt;br/&gt;\"\n            \"Please remove these files manually or use `Repair` action to \"\n            \"delete them.\"\n        )\n\n    if len(collections) &gt; 1:\n        raise PublishValidationError(\n            f\"Folders {checked_folders} contain multiple collections \"\n            f\"{collections}. &lt;br/&gt;&lt;br/&gt;\"\n            f\"This will cause issue during extraction of review.&lt;br/&gt;&lt;br/&gt;\"\n            \"Please remove one of the collections manually!\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_rendered_files.html#client.ayon_aftereffects.plugins.publish.validate_rendered_files.ValidateRenderedFiles.repair","title":"<code>repair(instance)</code>  <code>classmethod</code>","text":"<p>Deletes out of sequence files from output dir(s).</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_rendered_files.py</code> <pre><code>@classmethod\ndef repair(cls, instance):\n    \"\"\"Deletes out of sequence files from output dir(s).\"\"\"\n    collected_files = cls._get_collected_files(instance)\n    checked_folders = cls._get_checked_folders(instance)\n\n    _, remainders = cls._get_collections_and_remainders(collected_files)\n\n    for remainder_file_name in remainders:\n        for checked_folder in checked_folders:\n            file_path = os.path.join(checked_folder, remainder_file_name)\n            if os.path.exists(file_path):\n                cls.log.warning(f\"Removing {file_path}\")\n                os.remove(file_path)\n                continue\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_scene_settings.html","title":"validate_scene_settings","text":"<p>Validate scene settings. Requires:     instance    -&gt; folderEntity     instance    -&gt; anatomyData</p>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/validate_scene_settings.html#client.ayon_aftereffects.plugins.publish.validate_scene_settings.ValidateSceneSettings","title":"<code>ValidateSceneSettings</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>InstancePlugin</code></p> <p>Ensures that Composition Settings (right mouse on comp) are same as task or folder attributes in AYON.</p> <p>By default checks only duration - how many frames should be rendered. Compares:     Frame start - Frame end + 1 against duration in Composition Settings.</p> If this complains <p>Check error message where is discrepancy. Check/modify rendered Composition Settings.</p> <p>If you know what you are doing run publishing again, uncheck this validation before Validation phase.</p> Source code in <code>client/ayon_aftereffects/plugins/publish/validate_scene_settings.py</code> <pre><code>class ValidateSceneSettings(OptionalPyblishPluginMixin,\n                            pyblish.api.InstancePlugin):\n    \"\"\"Ensures that Composition Settings (right mouse on comp) are same as\n    task or folder attributes in AYON.\n\n    By default checks only duration - how many frames should be rendered.\n    Compares:\n        Frame start - Frame end + 1 against duration in Composition Settings.\n\n    If this complains:\n        Check error message where is discrepancy.\n        Check/modify rendered Composition Settings.\n\n    If you know what you are doing run publishing again, uncheck this\n    validation before Validation phase.\n    \"\"\"\n\n    \"\"\"\n        Dev docu:\n        Could be configured by 'presets/plugins/aftereffects/publish'\n\n        skip_timelines_check - fill task name for which skip validation of\n            frameStart\n            frameEnd\n            fps\n            handleStart\n            handleEnd\n        skip_resolution_check - fill entity type ('folder') to skip validation\n            resolutionWidth\n            resolutionHeight\n            TODO support in extension is missing for now\n\n         By defaults validates duration (how many frames should be published)\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Scene Settings\"\n    families = [\"render.farm\", \"render.local\", \"render\"]\n    hosts = [\"aftereffects\"]\n    settings_category = \"aftereffects\"\n    optional = True\n\n    skip_timelines_check = [\".*\"]  # * &gt;&gt; skip for all\n    skip_resolution_check = [\".*\"]\n\n    def process(self, instance):\n        # Skip the instance if is not active by data on the instance\n        if not self.is_active(instance.data):\n            return\n\n        entity: dict = (\n            instance.data.get(\"taskEntity\")\n            or instance.data[\"folderEntity\"]\n        )\n        expected_settings = get_entity_attributes(entity)\n        self.log.debug(f\"Found entity attributes: {expected_settings}\")\n\n        task_name: str = instance.data[\"task\"]\n        if any(re.search(pattern, task_name)\n                for pattern in self.skip_resolution_check):\n            self.log.debug(\n                f\"Skipping resolution check for task name: {task_name}\"\n            )\n            expected_settings.pop(\"resolutionWidth\")\n            expected_settings.pop(\"resolutionHeight\")\n\n        if any(re.search(pattern, task_name)\n                for pattern in self.skip_timelines_check):\n            self.log.debug(\n                f\"Skipping frames check for task name: {task_name}\"\n            )\n            expected_settings.pop('fps', None)\n            expected_settings.pop('frameStart', None)\n            expected_settings.pop('frameEnd', None)\n            expected_settings.pop('handleStart', None)\n            expected_settings.pop('handleEnd', None)\n\n        # handle case where ftrack uses only two decimal places\n        # 23.976023976023978 vs. 23.98\n        fps = instance.data.get(\"fps\")\n        if fps:\n            if isinstance(fps, float):\n                fps = float(\n                    \"{:.2f}\".format(fps))\n            expected_settings[\"fps\"] = fps\n\n        duration = (\n            instance.data.get(\"frameEndHandle\")\n            - instance.data.get(\"frameStartHandle\")\n            + 1\n        )\n\n        self.log.debug(f\"Validating attributes: {expected_settings}\")\n\n        current_settings = {\n            \"fps\": fps,\n            \"frameStart\": instance.data.get(\"frameStart\"),\n            \"frameEnd\": instance.data.get(\"frameEnd\"),\n            \"handleStart\": instance.data.get(\"handleStart\"),\n            \"handleEnd\": instance.data.get(\"handleEnd\"),\n            \"frameStartHandle\": instance.data.get(\"frameStartHandle\"),\n            \"frameEndHandle\": instance.data.get(\"frameEndHandle\"),\n            \"resolutionWidth\": instance.data.get(\"resolutionWidth\"),\n            \"resolutionHeight\": instance.data.get(\"resolutionHeight\"),\n            \"duration\": duration\n        }\n        self.log.debug(f\"Comp attributes: {current_settings}\")\n\n        invalid_settings = []\n        invalid_keys = set()\n        for key, value in expected_settings.items():\n            if value != current_settings[key]:\n                msg = \"'{}' expected: '{}'  found: '{}'\".format(\n                    key, value, current_settings[key])\n\n                if key == \"duration\" and expected_settings.get(\"handleStart\"):\n                    msg += (\n                        \"Handles included in calculation. Remove \"\n                        \"handles in DB or extend frame range in \"\n                        \"Composition Setting.\"\n                    )\n\n                invalid_settings.append(msg)\n                invalid_keys.add(key)\n\n        if invalid_settings:\n            msg = \"Found invalid settings:\\n{}\".format(\n                \"\\n\".join(invalid_settings)\n            )\n\n            invalid_keys_str = \",\".join(invalid_keys)\n            break_str = \"&lt;br/&gt;\"\n            invalid_setting_str = \"&lt;b&gt;Found invalid settings:&lt;/b&gt;&lt;br/&gt;{}\".\\\n                format(break_str.join(invalid_settings))\n\n            formatting_data = {\n                \"invalid_setting_str\": invalid_setting_str,\n                \"invalid_keys_str\": invalid_keys_str\n            }\n            raise PublishXmlValidationError(self, msg,\n                                            formatting_data=formatting_data)\n\n        if not os.path.exists(instance.data.get(\"source\")):\n            scene_url = instance.data.get(\"source\")\n            msg = \"Scene file {} not found (saved under wrong name)\".format(\n                scene_url\n            )\n            formatting_data = {\n                \"scene_url\": scene_url\n            }\n            raise PublishXmlValidationError(self, msg, key=\"file_not_found\",\n                                            formatting_data=formatting_data)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/publish/help/index.html","title":"help","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/index.html","title":"workfile_build","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/create_placeholder.html","title":"create_placeholder","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/create_placeholder.html#client.ayon_aftereffects.plugins.workfile_build.create_placeholder.AEPlaceholderCreatePlugin","title":"<code>AEPlaceholderCreatePlugin</code>","text":"<p>               Bases: <code>AEPlaceholderPlugin</code>, <code>PlaceholderCreateMixin</code></p> <p>Adds Create placeholder.</p> <p>This adds composition and runs Create</p> Source code in <code>client/ayon_aftereffects/plugins/workfile_build/create_placeholder.py</code> <pre><code>class AEPlaceholderCreatePlugin(wtb.AEPlaceholderPlugin,\n                                PlaceholderCreateMixin):\n    \"\"\"Adds Create placeholder.\n\n    This adds composition and runs Create\n    \"\"\"\n    identifier = \"aftereffects.create\"\n    label = \"AfterEffects create\"\n\n    def _create_placeholder_item(self, item_data) -&gt; CreatePlaceholderItem:\n        return CreatePlaceholderItem(\n            scene_identifier=item_data[\"uuid\"],\n            data=item_data[\"data\"],\n            plugin=self\n        )\n\n    def create_placeholder(self, placeholder_data):\n        stub = get_stub()\n        name = \"CREATEPLACEHOLDER\"\n        item_id = stub.add_item(name, \"COMP\")\n\n        self._imprint_item(item_id, name, placeholder_data, stub)\n\n    def populate_placeholder(self, placeholder):\n        \"\"\"Replace 'placeholder' with publishable instance.\n\n        Renames prepared composition name, creates publishable instance, sets\n        frame/duration settings according to DB.\n        \"\"\"\n        pre_create_data = {\"use_selection\": True}\n        item_id, item = self._get_item(placeholder)\n        get_stub().select_items([item_id])\n        self.populate_create_placeholder(placeholder, pre_create_data)\n\n        # apply settings for populated composition\n        item_id, metadata_item = self._get_item(placeholder)\n        set_settings(True, True, [item_id])\n\n    def get_placeholder_options(self, options=None):\n        return self.get_create_plugin_options(options)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/create_placeholder.html#client.ayon_aftereffects.plugins.workfile_build.create_placeholder.AEPlaceholderCreatePlugin.populate_placeholder","title":"<code>populate_placeholder(placeholder)</code>","text":"<p>Replace 'placeholder' with publishable instance.</p> <p>Renames prepared composition name, creates publishable instance, sets frame/duration settings according to DB.</p> Source code in <code>client/ayon_aftereffects/plugins/workfile_build/create_placeholder.py</code> <pre><code>def populate_placeholder(self, placeholder):\n    \"\"\"Replace 'placeholder' with publishable instance.\n\n    Renames prepared composition name, creates publishable instance, sets\n    frame/duration settings according to DB.\n    \"\"\"\n    pre_create_data = {\"use_selection\": True}\n    item_id, item = self._get_item(placeholder)\n    get_stub().select_items([item_id])\n    self.populate_create_placeholder(placeholder, pre_create_data)\n\n    # apply settings for populated composition\n    item_id, metadata_item = self._get_item(placeholder)\n    set_settings(True, True, [item_id])\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/load_placeholder.html","title":"load_placeholder","text":""},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/load_placeholder.html#client.ayon_aftereffects.plugins.workfile_build.load_placeholder.AEPlaceholderLoadPlugin","title":"<code>AEPlaceholderLoadPlugin</code>","text":"<p>               Bases: <code>AEPlaceholderPlugin</code>, <code>PlaceholderLoadMixin</code></p> Source code in <code>client/ayon_aftereffects/plugins/workfile_build/load_placeholder.py</code> <pre><code>class AEPlaceholderLoadPlugin(wtb.AEPlaceholderPlugin, PlaceholderLoadMixin):\n    identifier = \"aftereffects.load\"\n    label = \"AfterEffects load\"\n\n    def _create_placeholder_item(self, item_data) -&gt; LoadPlaceholderItem:\n        return LoadPlaceholderItem(\n            scene_identifier=item_data[\"uuid\"],\n            data=item_data[\"data\"],\n            plugin=self\n        )\n\n    def create_placeholder(self, placeholder_data):\n        \"\"\"Creates AE's Placeholder item in Project items list.\n\n         Sets dummy resolution/duration/fps settings, will be replaced when\n         populated.\n         \"\"\"\n        stub = get_stub()\n        name = \"LOADERPLACEHOLDER\"\n        item_id = stub.add_placeholder(name, 1920, 1060, 25, 10)\n\n        self._imprint_item(item_id, name, placeholder_data, stub)\n\n    def populate_placeholder(self, placeholder):\n        \"\"\"Use AYON Loader from `placeholder` to create new FootageItems\n\n        New FootageItems are created, files are imported.\n        \"\"\"\n        self.populate_load_placeholder(placeholder)\n        errors = placeholder.get_errors()\n        stub = get_stub()\n        if errors:\n            stub.print_msg(\"\\n\".join(errors))\n        else:\n            if not placeholder.data[\"keep_placeholder\"]:\n                metadata = stub.get_metadata()\n                for item in metadata:\n                    if not item.get(\"is_placeholder\"):\n                        continue\n                    scene_identifier = item.get(\"uuid\")\n                    if (scene_identifier and\n                            scene_identifier == placeholder.scene_identifier):\n                        stub.delete_item(item[\"members\"][0])\n                stub.remove_instance(placeholder.scene_identifier, metadata)\n\n    def get_placeholder_options(self, options=None):\n        return self.get_load_plugin_options(options)\n\n    def load_succeed(self, placeholder, container):\n        placeholder_item_id, _ = self._get_item(placeholder)\n        item_id = container.id\n        get_stub().add_item_instead_placeholder(placeholder_item_id, item_id)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/load_placeholder.html#client.ayon_aftereffects.plugins.workfile_build.load_placeholder.AEPlaceholderLoadPlugin.create_placeholder","title":"<code>create_placeholder(placeholder_data)</code>","text":"<p>Creates AE's Placeholder item in Project items list.</p> <p>Sets dummy resolution/duration/fps settings, will be replaced when populated.</p> Source code in <code>client/ayon_aftereffects/plugins/workfile_build/load_placeholder.py</code> <pre><code>def create_placeholder(self, placeholder_data):\n    \"\"\"Creates AE's Placeholder item in Project items list.\n\n     Sets dummy resolution/duration/fps settings, will be replaced when\n     populated.\n     \"\"\"\n    stub = get_stub()\n    name = \"LOADERPLACEHOLDER\"\n    item_id = stub.add_placeholder(name, 1920, 1060, 25, 10)\n\n    self._imprint_item(item_id, name, placeholder_data, stub)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/plugins/workfile_build/load_placeholder.html#client.ayon_aftereffects.plugins.workfile_build.load_placeholder.AEPlaceholderLoadPlugin.populate_placeholder","title":"<code>populate_placeholder(placeholder)</code>","text":"<p>Use AYON Loader from <code>placeholder</code> to create new FootageItems</p> <p>New FootageItems are created, files are imported.</p> Source code in <code>client/ayon_aftereffects/plugins/workfile_build/load_placeholder.py</code> <pre><code>def populate_placeholder(self, placeholder):\n    \"\"\"Use AYON Loader from `placeholder` to create new FootageItems\n\n    New FootageItems are created, files are imported.\n    \"\"\"\n    self.populate_load_placeholder(placeholder)\n    errors = placeholder.get_errors()\n    stub = get_stub()\n    if errors:\n        stub.print_msg(\"\\n\".join(errors))\n    else:\n        if not placeholder.data[\"keep_placeholder\"]:\n            metadata = stub.get_metadata()\n            for item in metadata:\n                if not item.get(\"is_placeholder\"):\n                    continue\n                scene_identifier = item.get(\"uuid\")\n                if (scene_identifier and\n                        scene_identifier == placeholder.scene_identifier):\n                    stub.delete_item(item[\"members\"][0])\n            stub.remove_instance(placeholder.scene_identifier, metadata)\n</code></pre>"},{"location":"autoapi/client/ayon_aftereffects/resources/index.html","title":"resources","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/index.html#server.settings.AfterEffectsSettings","title":"<code>AfterEffectsSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>AfterEffects Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class AfterEffectsSettings(BaseSettingsModel):\n    \"\"\"AfterEffects Project Settings.\"\"\"\n\n    auto_install_extension: bool = SettingsField(\n        False,\n        title=\"Install AYON Extension\",\n        description=\"Triggers pre-launch hook which installs extension.\"\n    )\n\n    imageio: AfterEffectsImageIOModel = SettingsField(\n        default_factory=AfterEffectsImageIOModel, title=\"OCIO config\"\n    )\n    create: AfterEffectsCreatorPlugins = SettingsField(\n        default_factory=AfterEffectsCreatorPlugins, title=\"Creator plugins\"\n    )\n    publish: AfterEffectsPublishPlugins = SettingsField(\n        default_factory=AfterEffectsPublishPlugins, title=\"Publish plugins\"\n    )\n    workfile_builder: WorkfileBuilderPlugin = SettingsField(\n        default_factory=WorkfileBuilderPlugin, title=\"Workfile Builder\"\n    )\n    templated_workfile_build: TemplatedWorkfileBuildModel = SettingsField(\n        default_factory=TemplatedWorkfileBuildModel,\n        title=\"Templated Workfile Build Settings\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/creator_plugins.html","title":"creator_plugins","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.AfterEffectsSettings","title":"<code>AfterEffectsSettings</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>AfterEffects Project Settings.</p> Source code in <code>server/settings/main.py</code> <pre><code>class AfterEffectsSettings(BaseSettingsModel):\n    \"\"\"AfterEffects Project Settings.\"\"\"\n\n    auto_install_extension: bool = SettingsField(\n        False,\n        title=\"Install AYON Extension\",\n        description=\"Triggers pre-launch hook which installs extension.\"\n    )\n\n    imageio: AfterEffectsImageIOModel = SettingsField(\n        default_factory=AfterEffectsImageIOModel, title=\"OCIO config\"\n    )\n    create: AfterEffectsCreatorPlugins = SettingsField(\n        default_factory=AfterEffectsCreatorPlugins, title=\"Creator plugins\"\n    )\n    publish: AfterEffectsPublishPlugins = SettingsField(\n        default_factory=AfterEffectsPublishPlugins, title=\"Publish plugins\"\n    )\n    workfile_builder: WorkfileBuilderPlugin = SettingsField(\n        default_factory=WorkfileBuilderPlugin, title=\"Workfile Builder\"\n    )\n    templated_workfile_build: TemplatedWorkfileBuildModel = SettingsField(\n        default_factory=TemplatedWorkfileBuildModel,\n        title=\"Templated Workfile Build Settings\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ValidateSceneSettingsModel","title":"<code>ValidateSceneSettingsModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Validate naming of products and layers</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ValidateSceneSettingsModel(BaseSettingsModel):\n    \"\"\"Validate naming of products and layers\"\"\"\n\n    # _isGroup = True\n    enabled: bool = SettingsField(True, title=\"Enabled\")\n    optional: bool = SettingsField(False, title=\"Optional\")\n    active: bool = SettingsField(True, title=\"Active\")\n    skip_resolution_check: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Resolution Check for Tasks\",\n    )\n    skip_timelines_check: list[str] = SettingsField(\n        default_factory=list,\n        title=\"Skip Timeline Check for Tasks\",\n    )\n</code></pre>"},{"location":"autoapi/server/settings/templated_workfile_build.html","title":"templated_workfile_build","text":""},{"location":"autoapi/server/settings/templated_workfile_build.html#server.settings.templated_workfile_build.TemplatedWorkfileBuildModel","title":"<code>TemplatedWorkfileBuildModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Workfile template builder with dynamic items via Placeholders</p> Source code in <code>server/settings/templated_workfile_build.py</code> <pre><code>class TemplatedWorkfileBuildModel(BaseSettingsModel):\n    \"\"\"Workfile template builder with dynamic items via Placeholders\"\"\"\n    profiles: list[TemplatedWorkfileProfileModel] = SettingsField(\n        default_factory=list\n    )\n</code></pre>"},{"location":"autoapi/server/settings/workfile_builder.html","title":"workfile_builder","text":""},{"location":"autoapi/server/settings/workfile_builder.html#server.settings.workfile_builder.WorkfileBuilderPlugin","title":"<code>WorkfileBuilderPlugin</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Simpler workfile template based on Task type</p> Source code in <code>server/settings/workfile_builder.py</code> <pre><code>class WorkfileBuilderPlugin(BaseSettingsModel):\n    \"\"\"Simpler workfile template based on Task type\"\"\"\n    _title = \"Workfile Builder\"\n    create_first_version: bool = SettingsField(\n        False,\n        title=\"Create first workfile\",\n        description=\"Save first workfile with the built template on \"\n                    \"first run if no existing workfile exists.\"\n    )\n\n    custom_templates: list[CustomBuilderTemplate] = SettingsField(\n        default_factory=list\n    )\n</code></pre>"}]}